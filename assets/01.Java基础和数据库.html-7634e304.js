const l=JSON.parse('{"key":"v-bee3c594","path":"/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html","title":"Java基础和数据库","lang":"zh-CN","frontmatter":{"description":"01.什么是字节码?采用字节码的好处是什么? 在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。; 由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。跨平台。; 02.== 和 equals() 的区别 == 对于基本类...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html"}],["meta",{"property":"og:site_name","content":"真理并无尽头"}],["meta",{"property":"og:title","content":"Java基础和数据库"}],["meta",{"property":"og:description","content":"01.什么是字节码?采用字节码的好处是什么? 在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。; 由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。跨平台。; 02.== 和 equals() 的区别 == 对于基本类..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-03-13T05:00:04.000Z"}],["meta",{"property":"article:modified_time","content":"2023-03-13T05:00:04.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java基础和数据库\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-03-13T05:00:04.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"01.什么是字节码?采用字节码的好处是什么?","slug":"_01-什么是字节码-采用字节码的好处是什么","link":"#_01-什么是字节码-采用字节码的好处是什么","children":[]},{"level":2,"title":"02.== 和 equals() 的区别","slug":"_02-和-equals-的区别","link":"#_02-和-equals-的区别","children":[]},{"level":2,"title":"03.hashCode() 与 equals()","slug":"_03-hashcode-与-equals","link":"#_03-hashcode-与-equals","children":[{"level":3,"title":"hashCode() 有什么用？","slug":"hashcode-有什么用","link":"#hashcode-有什么用","children":[]},{"level":3,"title":"为什么重写 equals() 时必须重写 hashCode() 方法？","slug":"为什么重写-equals-时必须重写-hashcode-方法","link":"#为什么重写-equals-时必须重写-hashcode-方法","children":[]}]},{"level":2,"title":"04.包装类型的常量池技术了解么？","slug":"_04-包装类型的常量池技术了解么","link":"#_04-包装类型的常量池技术了解么","children":[]},{"level":2,"title":"05.自动装箱与拆箱了解吗？原理是什么？","slug":"_05-自动装箱与拆箱了解吗-原理是什么","link":"#_05-自动装箱与拆箱了解吗-原理是什么","children":[]},{"level":2,"title":"06.面向对象三大特征","slug":"_06-面向对象三大特征","link":"#_06-面向对象三大特征","children":[]},{"level":2,"title":"07.接口和抽象类有什么共同点和区别？","slug":"_07-接口和抽象类有什么共同点和区别","link":"#_07-接口和抽象类有什么共同点和区别","children":[]},{"level":2,"title":"08.深拷贝和浅拷贝区别了解吗？什么是引用拷贝？","slug":"_08-深拷贝和浅拷贝区别了解吗-什么是引用拷贝","link":"#_08-深拷贝和浅拷贝区别了解吗-什么是引用拷贝","children":[]},{"level":2,"title":"09.Java 常见对象","slug":"_09-java-常见对象","link":"#_09-java-常见对象","children":[{"level":3,"title":"Object","slug":"object","link":"#object","children":[]},{"level":3,"title":"String","slug":"string","link":"#string","children":[]}]},{"level":2,"title":"10.泛型","slug":"_10-泛型","link":"#_10-泛型","children":[]},{"level":2,"title":"11.反射","slug":"_11-反射","link":"#_11-反射","children":[]},{"level":2,"title":"12.注解","slug":"_12-注解","link":"#_12-注解","children":[]},{"level":2,"title":"13.异常","slug":"_13-异常","link":"#_13-异常","children":[]},{"level":2,"title":"14.I/O","slug":"_14-i-o","link":"#_14-i-o","children":[]},{"level":2,"title":"15.为什么 Java 中只有值传递？","slug":"_15-为什么-java-中只有值传递","link":"#_15-为什么-java-中只有值传递","children":[]},{"level":2,"title":"16.集合框架底层数据结构总结","slug":"_16-集合框架底层数据结构总结","link":"#_16-集合框架底层数据结构总结","children":[]},{"level":2,"title":"17.为什么要使用集合？","slug":"_17-为什么要使用集合","link":"#_17-为什么要使用集合","children":[]},{"level":2,"title":"18.Collection 子接口之 List","slug":"_18-collection-子接口之-list","link":"#_18-collection-子接口之-list","children":[]},{"level":2,"title":"19.Arraylist 与 LinkedList 区别?","slug":"_19-arraylist-与-linkedlist-区别","link":"#_19-arraylist-与-linkedlist-区别","children":[]},{"level":2,"title":"20.ArrayList 的扩容机制","slug":"_20-arraylist-的扩容机制","link":"#_20-arraylist-的扩容机制","children":[]},{"level":2,"title":"21.comparable 和 Comparator 的区别","slug":"_21-comparable-和-comparator-的区别","link":"#_21-comparable-和-comparator-的区别","children":[]},{"level":2,"title":"22.无序性和不可重复性的含义是什么","slug":"_22-无序性和不可重复性的含义是什么","link":"#_22-无序性和不可重复性的含义是什么","children":[]},{"level":2,"title":"23.比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同","slug":"_23-比较-hashset、linkedhashset-和-treeset-三者的异同","link":"#_23-比较-hashset、linkedhashset-和-treeset-三者的异同","children":[]},{"level":2,"title":"24.HashMap 和 HashSet 区别","slug":"_24-hashmap-和-hashset-区别","link":"#_24-hashmap-和-hashset-区别","children":[]},{"level":2,"title":"25.HashSet 如何检查重复","slug":"_25-hashset-如何检查重复","link":"#_25-hashset-如何检查重复","children":[]},{"level":2,"title":"26.HashMap 的底层实现","slug":"_26-hashmap-的底层实现","link":"#_26-hashmap-的底层实现","children":[]},{"level":2,"title":"27.HashMap 的长度为什么是 2 的幂次方","slug":"_27-hashmap-的长度为什么是-2-的幂次方","link":"#_27-hashmap-的长度为什么是-2-的幂次方","children":[]},{"level":2,"title":"28.HashMap 多线程操作导致死循环问题","slug":"_28-hashmap-多线程操作导致死循环问题","link":"#_28-hashmap-多线程操作导致死循环问题","children":[]},{"level":2,"title":"29.HashMap 有哪几种常见的遍历方式?","slug":"_29-hashmap-有哪几种常见的遍历方式","link":"#_29-hashmap-有哪几种常见的遍历方式","children":[]},{"level":2,"title":"30.ConcurrentHashMap 和 Hashtable 的区别","slug":"_30-concurrenthashmap-和-hashtable-的区别","link":"#_30-concurrenthashmap-和-hashtable-的区别","children":[]},{"level":2,"title":"31.Collections 工具类常用方法","slug":"_31-collections-工具类常用方法","link":"#_31-collections-工具类常用方法","children":[]},{"level":2,"title":"32.请简要描述线程与进程的关系,区别及优缺点？","slug":"_32-请简要描述线程与进程的关系-区别及优缺点","link":"#_32-请简要描述线程与进程的关系-区别及优缺点","children":[]},{"level":2,"title":"33.为什么要使用多线程呢?","slug":"_33-为什么要使用多线程呢","link":"#_33-为什么要使用多线程呢","children":[]},{"level":2,"title":"34.使用多线程可能带来什么问题?","slug":"_34-使用多线程可能带来什么问题","link":"#_34-使用多线程可能带来什么问题","children":[]},{"level":2,"title":"35.说说线程的生命周期和状态?","slug":"_35-说说线程的生命周期和状态","link":"#_35-说说线程的生命周期和状态","children":[]},{"level":2,"title":"36.什么是上下文切换?","slug":"_36-什么是上下文切换","link":"#_36-什么是上下文切换","children":[]},{"level":2,"title":"37.什么是线程死锁?如何避免死锁?","slug":"_37-什么是线程死锁-如何避免死锁","link":"#_37-什么是线程死锁-如何避免死锁","children":[]},{"level":2,"title":"38.说说 sleep() 方法和 wait() 方法区别和共同点?","slug":"_38-说说-sleep-方法和-wait-方法区别和共同点","link":"#_38-说说-sleep-方法和-wait-方法区别和共同点","children":[]},{"level":2,"title":"39.为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？","slug":"_39-为什么我们调用-start-方法时会执行-run-方法-为什么我们不能直接调用-run-方法","link":"#_39-为什么我们调用-start-方法时会执行-run-方法-为什么我们不能直接调用-run-方法","children":[]},{"level":2,"title":"40.说一说自己对于 synchronized 关键字的了解","slug":"_40-说一说自己对于-synchronized-关键字的了解","link":"#_40-说一说自己对于-synchronized-关键字的了解","children":[]},{"level":2,"title":"41.说说自己是怎么使用 synchronized 关键字","slug":"_41-说说自己是怎么使用-synchronized-关键字","link":"#_41-说说自己是怎么使用-synchronized-关键字","children":[]},{"level":2,"title":"42.构造方法可以使用 synchronized 关键字修饰么？","slug":"_42-构造方法可以使用-synchronized-关键字修饰么","link":"#_42-构造方法可以使用-synchronized-关键字修饰么","children":[]},{"level":2,"title":"43.讲一下 synchronized 关键字的底层原理","slug":"_43-讲一下-synchronized-关键字的底层原理","link":"#_43-讲一下-synchronized-关键字的底层原理","children":[]},{"level":2,"title":"44.说说 JDK1.6 之后的 synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗","slug":"_44-说说-jdk1-6-之后的-synchronized-关键字底层做了哪些优化-可以详细介绍一下这些优化吗","link":"#_44-说说-jdk1-6-之后的-synchronized-关键字底层做了哪些优化-可以详细介绍一下这些优化吗","children":[]},{"level":2,"title":"45.谈谈 synchronized 和 ReentrantLock 的区别","slug":"_45-谈谈-synchronized-和-reentrantlock-的区别","link":"#_45-谈谈-synchronized-和-reentrantlock-的区别","children":[]},{"level":2,"title":"46.CPU 缓存模型","slug":"_46-cpu-缓存模型","link":"#_46-cpu-缓存模型","children":[]},{"level":2,"title":"47.讲一下 JMM(Java 内存模型)","slug":"_47-讲一下-jmm-java-内存模型","link":"#_47-讲一下-jmm-java-内存模型","children":[]},{"level":2,"title":"48.并发编程的三个重要特性","slug":"_48-并发编程的三个重要特性","link":"#_48-并发编程的三个重要特性","children":[]},{"level":2,"title":"49.说说 synchronized 关键字和 volatile 关键字的区别","slug":"_49-说说-synchronized-关键字和-volatile-关键字的区别","link":"#_49-说说-synchronized-关键字和-volatile-关键字的区别","children":[]},{"level":2,"title":"50.ThreadLocal","slug":"_50-threadlocal","link":"#_50-threadlocal","children":[]},{"level":2,"title":"51.为什么要用线程池？","slug":"_51-为什么要用线程池","link":"#_51-为什么要用线程池","children":[]},{"level":2,"title":"52.实现 Runnable 接口和 Callable 接口的区别","slug":"_52-实现-runnable-接口和-callable-接口的区别","link":"#_52-实现-runnable-接口和-callable-接口的区别","children":[]},{"level":2,"title":"53.执行 execute()方法和 submit()方法的区别是什么呢？","slug":"_53-执行-execute-方法和-submit-方法的区别是什么呢","link":"#_53-执行-execute-方法和-submit-方法的区别是什么呢","children":[]},{"level":2,"title":"54.如何创建线程池","slug":"_54-如何创建线程池","link":"#_54-如何创建线程池","children":[]},{"level":2,"title":"55.线程池的七个参数","slug":"_55-线程池的七个参数","link":"#_55-线程池的七个参数","children":[]},{"level":2,"title":"56.CAS和AQS","slug":"_56-cas和aqs","link":"#_56-cas和aqs","children":[]},{"level":2,"title":"57.用过 CountDownLatch 么？什么场景下用的？","slug":"_57-用过-countdownlatch-么-什么场景下用的","link":"#_57-用过-countdownlatch-么-什么场景下用的","children":[]},{"level":2,"title":"58.介绍下 Java 内存区域（运行时数据区）","slug":"_58-介绍下-java-内存区域-运行时数据区","link":"#_58-介绍下-java-内存区域-运行时数据区","children":[]},{"level":2,"title":"59.对象的创建","slug":"_59-对象的创建","link":"#_59-对象的创建","children":[]},{"level":2,"title":"60.字符串常量池常见问题","slug":"_60-字符串常量池常见问题","link":"#_60-字符串常量池常见问题","children":[]},{"level":2,"title":"61.类加载过程","slug":"_61-类加载过程","link":"#_61-类加载过程","children":[]},{"level":2,"title":"MySQL","slug":"mysql","link":"#mysql","children":[]},{"level":2,"title":"62.锁机制与 InnoDB 锁算法","slug":"_62-锁机制与-innodb-锁算法","link":"#_62-锁机制与-innodb-锁算法","children":[]},{"level":2,"title":"63.查询缓存","slug":"_63-查询缓存","link":"#_63-查询缓存","children":[]},{"level":2,"title":"64.何为事务？","slug":"_64-何为事务","link":"#_64-何为事务","children":[]},{"level":2,"title":"65.何为数据库事务？","slug":"_65-何为数据库事务","link":"#_65-何为数据库事务","children":[]},{"level":2,"title":"66.何为 ACID 特性呢？","slug":"_66-何为-acid-特性呢","link":"#_66-何为-acid-特性呢","children":[]},{"level":2,"title":"67.数据事务的实现原理呢？","slug":"_67-数据事务的实现原理呢","link":"#_67-数据事务的实现原理呢","children":[]},{"level":2,"title":"68.并发事务带来哪些问题?","slug":"_68-并发事务带来哪些问题","link":"#_68-并发事务带来哪些问题","children":[]},{"level":2,"title":"69.事务隔离级别有哪些?","slug":"_69-事务隔离级别有哪些","link":"#_69-事务隔离级别有哪些","children":[]},{"level":2,"title":"70.MySQL 的默认隔离级别是什么?","slug":"_70-mysql-的默认隔离级别是什么","link":"#_70-mysql-的默认隔离级别是什么","children":[]},{"level":2,"title":"71.MySQL 索引详解","slug":"_71-mysql-索引详解","link":"#_71-mysql-索引详解","children":[{"level":3,"title":"何为索引？有什么作用？","slug":"何为索引-有什么作用","link":"#何为索引-有什么作用","children":[]},{"level":3,"title":"索引的优缺点","slug":"索引的优缺点","link":"#索引的优缺点","children":[]},{"level":3,"title":"索引的底层数据结构","slug":"索引的底层数据结构","link":"#索引的底层数据结构","children":[]},{"level":3,"title":"索引类型","slug":"索引类型","link":"#索引类型","children":[]},{"level":3,"title":"explain的用法","slug":"explain的用法","link":"#explain的用法","children":[]},{"level":3,"title":"使用索引的问题","slug":"使用索引的问题","link":"#使用索引的问题","children":[]}]},{"level":2,"title":"Redis","slug":"redis","link":"#redis","children":[]},{"level":2,"title":"72.什么是 Redis？","slug":"_72-什么是-redis","link":"#_72-什么是-redis","children":[]},{"level":2,"title":"73.Redis 为什么这么快？","slug":"_73-redis-为什么这么快","link":"#_73-redis-为什么这么快","children":[]},{"level":2,"title":"74.Redis 除了做缓存，还能做什么？","slug":"_74-redis-除了做缓存-还能做什么","link":"#_74-redis-除了做缓存-还能做什么","children":[]},{"level":2,"title":"75.Redis 数据结构","slug":"_75-redis-数据结构","link":"#_75-redis-数据结构","children":[]},{"level":2,"title":"76.Redis 线程模型","slug":"_76-redis-线程模型","link":"#_76-redis-线程模型","children":[]},{"level":2,"title":"77.Redis 内存管理","slug":"_77-redis-内存管理","link":"#_77-redis-内存管理","children":[]},{"level":2,"title":"78.Redis 持久化机制","slug":"_78-redis-持久化机制","link":"#_78-redis-持久化机制","children":[]},{"level":2,"title":"79.缓存问题","slug":"_79-缓存问题","link":"#_79-缓存问题","children":[{"level":3,"title":"缓存穿透","slug":"缓存穿透","link":"#缓存穿透","children":[]},{"level":3,"title":"缓存雪崩","slug":"缓存雪崩","link":"#缓存雪崩","children":[]}]},{"level":2,"title":"80.3种常用的缓存读写策略","slug":"_80-3种常用的缓存读写策略","link":"#_80-3种常用的缓存读写策略","children":[{"level":3,"title":"Cache Aside Pattern（旁路缓存模式）","slug":"cache-aside-pattern-旁路缓存模式","link":"#cache-aside-pattern-旁路缓存模式","children":[]},{"level":3,"title":"Read/Write Through Pattern（读写穿透）","slug":"read-write-through-pattern-读写穿透","link":"#read-write-through-pattern-读写穿透","children":[]},{"level":3,"title":"Write Behind Pattern（异步缓存写入）","slug":"write-behind-pattern-异步缓存写入","link":"#write-behind-pattern-异步缓存写入","children":[]}]},{"level":2,"title":"81.Redis 内存碎片","slug":"_81-redis-内存碎片","link":"#_81-redis-内存碎片","children":[]}],"git":{"createdTime":1678683604000,"updatedTime":1678683604000,"contributors":[{"name":"HeJin","email":"deciphers@163.com","commits":1}]},"readingTime":{"minutes":67.74,"words":20322},"filePathRelative":"interview/01.Java基础和数据库.md","localizedDate":"2023年3月13日","autoDesc":true}');export{l as data};
