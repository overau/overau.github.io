import{_ as e,V as i,W as a,X as o}from"./framework-a569e214.js";const n={},r=o('<h1 id="常用框架" tabindex="-1"><a class="header-anchor" href="#常用框架" aria-hidden="true">#</a> 常用框架</h1><h1 id="spring框架" tabindex="-1"><a class="header-anchor" href="#spring框架" aria-hidden="true">#</a> <mark>Spring框架</mark></h1><h2 id="_1-什么是-spring-框架" tabindex="-1"><a class="header-anchor" href="#_1-什么是-spring-框架" aria-hidden="true">#</a> 1.什么是 Spring 框架?</h2><ul><li>Spring 是一款开源的轻量级 Java 开发框架，旨在提高开发人员的开发效率以及系统的可维护性。</li><li>Spring 提供的核心功能主要是 IoC 和 AOP。学习 Spring ，一定要把 IoC 和 AOP 的核心思想搞懂！</li></ul><h2 id="_2-谈谈自己对于-spring-ioc-的了解" tabindex="-1"><a class="header-anchor" href="#_2-谈谈自己对于-spring-ioc-的了解" aria-hidden="true">#</a> 2.谈谈自己对于 Spring IoC 的了解</h2><ul><li>IoC（Inverse of Control:控制反转） 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。不过， IoC 并非 Spring 特有，在其他语言中也有应用。</li><li>为什么叫控制反转？控制 ：指的是对象创建（实例化、管理）的权力。反转 ：控制权交给外部环境（Spring 框架、IoC 容器）。</li><li>将对象之间的<strong>相互依赖关系</strong>交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。</li></ul><h2 id="_3-谈谈自己对于-aop-的了解" tabindex="-1"><a class="header-anchor" href="#_3-谈谈自己对于-aop-的了解" aria-hidden="true">#</a> 3.谈谈自己对于 AOP 的了解</h2><ul><li>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</li><li>Spring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 JDK Proxy，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 Cglib 生成一个被代理对象的子类来作为代理。</li></ul><h2 id="_4-什么是-bean" tabindex="-1"><a class="header-anchor" href="#_4-什么是-bean" aria-hidden="true">#</a> 4.什么是 bean？</h2><ul><li>简单来说，bean 代指的就是那些被 IoC 容器所管理的对象。</li><li>我们需要告诉 IoC 容器帮助我们管理哪些对象，这个是通过配置元数据来定义的。配置元数据可以是 XML 文件、注解或者 Java 配置类。</li></ul><h2 id="_5-bean-的作用域有哪些" tabindex="-1"><a class="header-anchor" href="#_5-bean-的作用域有哪些" aria-hidden="true">#</a> 5.bean 的作用域有哪些?</h2><p>Spring 中 Bean 的作用域通常有下面几种：</p><ul><li>singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的，对单例设计模式的应用。</li><li>prototype : 每次请求都会创建一个新的 bean 实例。</li><li>request : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。</li><li>session : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。</li><li>global-session ： 全局 session 作用域，仅仅在基于 portlet 的 web 应用中才有意义，Spring5 已经没有了。Portlet 是能够生成语义代码(例如：HTML)片段的小型 Java Web 插件。它们基于 portlet 容器，可以像 servlet 一样处理 HTTP 请求。但是，与 servlet 不同，每个 portlet 都有不同的会话。</li></ul><h2 id="_6-单例-bean-的线程安全问题了解吗" tabindex="-1"><a class="header-anchor" href="#_6-单例-bean-的线程安全问题了解吗" aria-hidden="true">#</a> 6.单例 bean 的线程安全问题了解吗？</h2><ul><li>部分时候我们并没有在项目中使用多线程，所以很少有人会关注这个问题。单例 bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候是存在资源竞争的。</li><li>常见的有两种解决办法： <ul><li>在 bean 中尽量避免定义可变的成员变量。</li><li>在类中定义一个 <code>ThreadLocal</code> 成员变量，将需要的可变成员变量保存在 <code>ThreadLocal</code> 中（推荐的一种方式）。</li></ul></li><li>不过，大部分 bean 实际都是无状态（没有实例变量）的（比如 Dao、Service），这种情况下， bean 是线程安全的。</li></ul><h2 id="_7-component-和-bean-的区别是什么" tabindex="-1"><a class="header-anchor" href="#_7-component-和-bean-的区别是什么" aria-hidden="true">#</a> 7.@Component 和 @Bean 的区别是什么？</h2><ul><li><code>@Component</code> 注解作用于类，而<code>@Bean</code>注解作用于方法。</li><li><code>@Component</code>通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中（我们可以使用 <code>@ComponentScan</code> 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。<code>@Bean</code> 注解通常是我们在标有该注解的方法中定义产生这个 bean,<code>@Bean</code>告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我。</li><li><code>@Bean</code> 注解比 <code>@Component</code> 注解的自定义性更强，而且很多地方我们只能通过 <code>@Bean</code> 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 <code>Spring</code>容器时，则只能通过 <code>@Bean</code>来实现。</li></ul><h2 id="_8-将一个类声明为-bean-的注解有哪些" tabindex="-1"><a class="header-anchor" href="#_8-将一个类声明为-bean-的注解有哪些" aria-hidden="true">#</a> 8.将一个类声明为 bean 的注解有哪些?</h2><p>我们一般使用 <code>@Autowired</code> 注解自动装配 bean，要想把类标识成可用于 <code>@Autowired</code> 注解自动装配的 bean 的类,采用以下注解可实现：</p><ul><li><code>@Component</code> ：通用的注解，可标注任意类为 <code>Spring</code> 组件。如果一个 Bean 不知道属于哪个层，可以使用<code>@Component</code> 注解标注。</li><li><code>@Repository</code> : 对应持久层即 Dao 层，主要用于数据库相关操作。</li><li><code>@Service</code> : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。</li><li><code>@Controller</code> : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。</li></ul><h2 id="_9-bean-的生命周期" tabindex="-1"><a class="header-anchor" href="#_9-bean-的生命周期" aria-hidden="true">#</a> 9.bean 的生命周期?</h2><ul><li><p>普通Java对象和Spring所管理Bean实例化的过程是有区别的。</p><ul><li>普通Java环境下创建对象：（1）java源码被编译为class文件。（2）等到类被初始化：new、反射等。（3）class文件被虚拟机通过<strong>类加载器</strong>加载的JVM。（4）初始化对象。简单来说，是通过<strong>Class对象作为模板</strong>进而创建出具体的实例。</li><li>Spring所管理的bean：除了<strong>Class对象</strong>，还会使用<strong>BeanDefinition的实例</strong>来描述对象的信息。<strong>Class对象描述了类的信息，BeanDefinition描述了对象的信息。</strong></li></ul></li><li><p>过程：</p><ol><li>Spring在启动的时候需要<strong>扫描</strong>在XML/注解/JavaConfig中需要被Spring管理的<strong>Bean信息</strong>。</li><li>然后，把这些信息封装成BeanDefinition。最后会把这些信息放到一个beanDefinitionMap中。key是beanName，value是BeanDefinition对象。这一步就是<strong>将定义的元数据加载起来</strong>，目前<strong>真实对象还没有被实例化</strong>。</li><li>接着会遍历这个beanDefinitionMap，执行BeanFactoryPostProcessor这个<strong>Bean工厂后置处理器</strong>的逻辑。在这里，我们也可以自定义BeanFactoryPostProcessor来对我们定义好的Bean元数据进行获取或者修改。</li><li>BeanFactoryPostProcessor后置处理器执行完之后，就到了实例化对象。Spring里面是通过反射来实现的，一般情况下会通过反射选择合适的构造器来把对象实例化。但这里把对象实例化，<strong>只是把对象给创建出来，而对象具体的属性还没注入</strong>。接下来就是对象的相关<strong>属性注入</strong>（循环依赖问题），属性注入完之后，就是初始化的工作。</li><li>Bean的初始化：首先判断该Bean是否实现了Aware相关的接口，如果存在则填充相关的资源。Aware相关的接口处理完之后，就会到<strong>BeanPostProcessor后置处理器</strong>了。BeanPostProcessor有两个方法，一个是before，一个是after。这个BeanPostProcessor后置处理器是<strong>AOP实现的关键</strong>。</li><li>BeanPostProcessor相关子类的before方法执行完，则执行init相关的方法。在对象实例化之后，我们如果需要初始化工作，就可以在init方法执行（比如把数据库的配置信息同步到redis等）。等init方法执行完之后，就会执行BeanPostProcessor的after方法。到这里，我们就可以获取到对象进行使用了。销毁的时候就看有没有配置相关的destroy方法，执行即可。</li></ol></li><li><p>循环依赖问题：三级缓存。三级缓存就是3个Map。singletonObjects（一级，日常实际获取Bean的地方）；earlySingletonObjects（二级，还没进行属性注入，由三级缓存放进来）；singletonFactories（三级，Value是一个对象工厂）。</p><ol><li>A对象实例化之后，属性注入之前，其实会把A对象放入三级缓存中。key是BeanName，Value是ObjectFactory。</li><li>等到A对象属性注入时，发现依赖B，又去实例化B时。</li><li>B属性注入需要去获取A对象，这里就是从三级缓存里拿出ObjectFactory，从ObjectFactory得到对应的Bean（就是对象A）。把三级缓存的A记录给干掉，然后放到二级缓存中。显然，二级缓存存储的key是BeanName，value就是Bean（这里的Bean还没做完属性注入相关的工作）。</li><li>等到完全初始化之后，就会把二级缓存给remove掉，塞到一级缓存中。我们自己去getBean的时候，实际上拿到的是一级缓存的。</li><li>为什么是三级缓存？我们的对象是单例的，有可能A对象依赖的B对象是有AOP的（B对象需要代理）。假设没有第三级缓存，只有第二级缓存（Value存对象，而不是工厂对象）。那如果有AOP的情况下，岂不是在存入第二级缓存之前都需要先去做AOP代理？这不合适。这里肯定是需要考虑代理的情况的，比如A对象是一个被AOP增量的对象，B依赖A时，得到的A肯定是代理对象的。所以，三级缓存的Value是ObjectFactory，可以从里边拿到<strong>代理对象</strong>。二级缓存存在的必要就是为了<strong>性能</strong>，从三级缓存的工厂里创建出对象，再扔到二级缓存（这样就不用每次都要从工厂里拿）。</li></ol></li></ul><h1 id="spring-mvc" tabindex="-1"><a class="header-anchor" href="#spring-mvc" aria-hidden="true">#</a> <mark>Spring MVC</mark></h1><h2 id="_10-说说自己对于-spring-mvc-了解" tabindex="-1"><a class="header-anchor" href="#_10-说说自己对于-spring-mvc-了解" aria-hidden="true">#</a> 10.说说自己对于 Spring MVC 了解?</h2><ul><li>MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。</li><li>网上有很多人说 MVC 不是设计模式，只是软件设计规范，我个人更倾向于 MVC 同样是众多设计模式中的一种。</li></ul><h2 id="_11-springmvc-工作原理了解吗" tabindex="-1"><a class="header-anchor" href="#_11-springmvc-工作原理了解吗" aria-hidden="true">#</a> 11.SpringMVC 工作原理了解吗?</h2><p><strong>流程说明（重要）：</strong></p><ol><li>客户端（浏览器）发送请求，直接请求到 <code>DispatcherServlet</code>。</li><li><code>DispatcherServlet</code> 根据请求信息调用 <code>HandlerMapping</code>，解析请求对应的 <code>Handler</code>。</li><li>解析到对应的 <code>Handler</code>（也就是我们平常说的 <code>Controller</code> 控制器）后，开始由 <code>HandlerAdapter</code> 适配器处理。</li><li><code>HandlerAdapter</code> 会根据 <code>Handler</code>来调用真正的处理器开处理请求，并处理相应的业务逻辑。</li><li>处理器处理完业务后，会返回一个 <code>ModelAndView</code> 对象，<code>Model</code> 是返回的数据对象，<code>View</code> 是个逻辑上的 <code>View</code>。</li><li><code>ViewResolver</code> 会根据逻辑 <code>View</code> 查找实际的 <code>View</code>。</li><li><code>DispaterServlet</code> 把返回的 <code>Model</code> 传给 <code>View</code>（视图渲染）。</li><li>把 <code>View</code> 返回给请求者（浏览器）。</li></ol><h2 id="_12-spring-框架中用到了哪些设计模式" tabindex="-1"><a class="header-anchor" href="#_12-spring-框架中用到了哪些设计模式" aria-hidden="true">#</a> 12.Spring 框架中用到了哪些设计模式？</h2><ul><li>工厂设计模式 : Spring 使用工厂模式通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 创建 bean 对象。</li><li>代理设计模式 : Spring AOP 功能的实现。</li><li>单例设计模式 : Spring 中的 Bean 默认都是单例的。</li><li>模板方法模式 : Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li><li>包装器设计模式 : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</li><li>观察者模式: Spring 事件驱动模型就是观察者模式很经典的一个应用。</li><li>适配器模式 : Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配<code>Controller</code>。</li><li>......</li></ul><h1 id="spring-事务" tabindex="-1"><a class="header-anchor" href="#spring-事务" aria-hidden="true">#</a> <mark>Spring 事务</mark></h1><h2 id="_13-什么是事务" tabindex="-1"><a class="header-anchor" href="#_13-什么是事务" aria-hidden="true">#</a> 13.什么是事务？</h2><ul><li>事务是逻辑上的一组操作，要么都执行，要么都不执行。</li><li>事务能否生效数据库引擎是否支持事务是关键。比如常用的 MySQL 数据库默认使用支持事务的 innodb引擎。但是，如果把数据库引擎变为 myisam，那么程序也就不再支持事务了！</li></ul><h2 id="_14-事务的特性-acid-了解么" tabindex="-1"><a class="header-anchor" href="#_14-事务的特性-acid-了解么" aria-hidden="true">#</a> 14.事务的特性（ACID）了解么?</h2><ul><li>原子性（Atomicity）： 一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。</li><li>一致性（Consistency）： 在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。</li><li>隔离性（Isolation）： 数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括未提交读（Read uncommitted）、提交读（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li><li>持久性（Durability）: 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li></ul><blockquote><p>MySQL 怎么保证原子性的？</p></blockquote><ul><li>想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行回滚。</li><li>在 MySQL 中，恢复机制是通过 回滚日志（undo log） 实现的，所有事务进行的修改都会先先记录到这个回滚日志中，然后再执行相关的操作。</li><li>如果执行过程中遇到异常的话，我们直接利用 回滚日志 中的信息将数据回滚到修改之前的样子即可！并且，回滚日志会先于数据持久化到磁盘上。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚将之前未完成的事务。</li></ul><h2 id="_15-spring-管理事务的方式有几种" tabindex="-1"><a class="header-anchor" href="#_15-spring-管理事务的方式有几种" aria-hidden="true">#</a> 15.Spring 管理事务的方式有几种？</h2><ul><li>Spring 并不直接管理事务，而是提供了多种事务管理器 。Spring 事务管理器的接口是PlatformTransactionManager 。</li><li>编程式事务 ： 在代码中硬编码(不推荐使用) : 通过 <code>TransactionTemplate</code>或者 <code>TransactionManager</code> 手动管理事务，实际应用中很少使用，但是对于你理解 Spring 事务管理原理有帮助。</li><li>声明式事务 ： 在 XML 配置文件中配置或者直接基于注解（推荐使用） : 实际是通过 AOP 实现（基于<code>@Transactional</code> 的全注解方式使用最多。</li></ul><h2 id="_16-spring-事务中哪几种事务传播行为" tabindex="-1"><a class="header-anchor" href="#_16-spring-事务中哪几种事务传播行为" aria-hidden="true">#</a> 16.Spring 事务中哪几种事务传播行为?</h2><blockquote><p>事务传播行为是为了解决业务层方法之间互相调用的事务问题。</p></blockquote><p>正确的事务传播行为可能的值如下:</p><p><code>TransactionDefinition.PROPAGATION_REQUIRED</code></p><p>使用的最多的一个事务传播行为，我们平时经常使用的<code>@Transactional</code>注解默认使用就是这个事务传播行为。如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</p><p><code>TransactionDefinition.PROPAGATION_REQUIRES_NEW</code></p><p>创建一个新的事务，如果当前存在事务，则把当前事务挂起。也就是说不管外部方法是否开启事务，<code>Propagation.REQUIRES_NEW</code>修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</p><p><code>TransactionDefinition.PROPAGATION_NESTED</code></p><p>如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于<code>TransactionDefinition.PROPAGATION_REQUIRED</code>。</p><p>如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</p><p><code>TransactionDefinition.PROPAGATION_MANDATORY</code></p><p>这个使用的很少。</p><p>若是错误的配置以下 3 种事务传播行为，事务将不会发生回滚：</p><ul><li><code>TransactionDefinition.PROPAGATION_SUPPORTS</code>: 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li><li><code>TransactionDefinition.PROPAGATION_NOT_SUPPORTED</code>: 以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li><li><code>TransactionDefinition.PROPAGATION_NEVER</code>: 以非事务方式运行，如果当前存在事务，则抛出异常。</li></ul><h2 id="_17-spring-事务中的隔离级别有哪几种" tabindex="-1"><a class="header-anchor" href="#_17-spring-事务中的隔离级别有哪几种" aria-hidden="true">#</a> 17.Spring 事务中的隔离级别有哪几种?</h2><p>和事务传播行为这块一样，为了方便使用，Spring 也相应地定义了一个枚举类：<code>Isolation</code></p><ul><li><code>TransactionDefinition.ISOLATION_DEFAULT</code> :使用后端数据库默认的隔离级别，MySQL 默认采用的 <code>REPEATABLE_READ</code> 隔离级别 Oracle 默认采用的 <code>READ_COMMITTED</code> 隔离级别.</li><li><code>TransactionDefinition.ISOLATION_READ_UNCOMMITTED</code> :最低的隔离级别，使用这个隔离级别很少，因为它允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读</li><li><code>TransactionDefinition.ISOLATION_READ_COMMITTED</code> : 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生</li><li><code>TransactionDefinition.ISOLATION_REPEATABLE_READ</code> : 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li><li><code>TransactionDefinition.ISOLATION_SERIALIZABLE</code> : 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li></ul><h2 id="_18-transactional-rollbackfor-exception-class-注解了解吗" tabindex="-1"><a class="header-anchor" href="#_18-transactional-rollbackfor-exception-class-注解了解吗" aria-hidden="true">#</a> 18.@Transactional(rollbackFor = Exception.class)注解了解吗？</h2><ul><li><code>Exception</code> 分为运行时异常 <code>RuntimeException</code> 和非运行时异常。事务管理对于企业应用来说是至关重要的，即使出现异常情况，它也可以保证数据的一致性。</li><li>当 <code>@Transactional</code> 注解作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。如果类或者方法加了这个注解，那么这个类里面的方法抛出异常，就会回滚，数据库里面的数据也会回滚。</li><li>在 <code>@Transactional</code> 注解中如果不配置<code>rollbackFor</code>属性,那么事务只会在遇到<code>RuntimeException</code>的时候才会回滚，加上 <code>rollbackFor=Exception.class</code>,可以让事务在遇到非运行时异常时也回滚。</li><li>若同一类中的其他没有 @Transactional 注解的方法内部调用有 @Transactional 注解的方法，有@Transactional 注解的方法的事务会失效。这是由于<code>Spring AOP</code>代理的原因造成的，因为只有当 <code>@Transactional</code> 注解的方法在类以外被调用的时候，Spring 事务管理才生效。</li></ul><p>​</p>',59),l=[r];function c(d,t){return i(),a("div",null,l)}const p=e(n,[["render",c],["__file","02.常用框架.html.vue"]]);export{p as default};
