import{_ as t,V as e,W as a,X as d}from"./framework-a569e214.js";const r="/img/elasticsearch/image-20210319090643924.png",c="/img/elasticsearch/image-20210319092101205.png",i="/img/elasticsearch/image-20210319091910026.png",s="/img/elasticsearch/image-20210319092346121.png",o={},l=d('<blockquote><p>集群、节点、索引、类型、文档、分片、映射是什么</p></blockquote><p><code>ElasticSearch是面向文档。一切都是json。</code></p><h2 id="关系型数据库和elasticsearch对比" tabindex="-1"><a class="header-anchor" href="#关系型数据库和elasticsearch对比" aria-hidden="true">#</a> 关系型数据库和ElasticSearch对比</h2><table><thead><tr><th>Relational DB</th><th>ElasticSearch</th></tr></thead><tbody><tr><td>数据库（database）</td><td>索引（indices）</td></tr><tr><td>表（table）</td><td>types（会被弃用）</td></tr><tr><td>行（rows）</td><td>documents</td></tr><tr><td>字段（columns）</td><td>fields</td></tr></tbody></table><p>ElasticSearch（集群）中可以包含多个索引（数据库），每个索引中可以包含多个类型（表），每个类型下又包含多个文档（行），每个文档又包含多个字段（列）。</p><blockquote><p>物理设计</p></blockquote><p>ElasticSearch在后台把每个索引分成多个分片，每个分片可以在集群中的不同服务器间迁移。</p><p>一个人就是一个集群。默认集群名称就是elasticsearch。</p><figure><img src="'+r+'" alt="image-20210319090643924" tabindex="0" loading="lazy"><figcaption>image-20210319090643924</figcaption></figure><blockquote><p>逻辑设计</p></blockquote><p>一个索引类型中，包含多个文档，比如说文档1、文档2。当我们索引一篇文档时，可以通过这样的一各顺序找到它：索引 -&gt; 类型 -&gt; 文档ID。通过这个组合我们就能索引到某个具体的文档。注意：ID不必是整数，实际上它是个字符串。</p><h2 id="文档" tabindex="-1"><a class="header-anchor" href="#文档" aria-hidden="true">#</a> 文档</h2><p>就是我们的一条条数据。</p><p>之前说elasticsearch是面向文档的，那么就意味着索引和搜索数据的最小单位是文档。elasticsearch中，文档有几个重要属性：</p><ul><li>自我包含。一篇文档同时包含字段和对应的值，也就是同时包含 key：value。</li><li>可以是层次型的，一个文档中包含自文档，复杂的逻辑实体就是这么来的。</li><li>灵活的结构，文档不依赖预先定义的模式。我们知道关系型数据库中，要提前定义字段才能使用。在elasticsearch中，对于字 段是非常灵活的。有时候，我们可以忽略该字段，或者动态的添加一个新的字段。</li></ul><p>尽管我们可以随意的新增或者忽略某个字段。但是，每个字段的类型非常重要，比如一个年龄字段类型，可以是字符串也可以是整</p><p>形。因为 elasticsearch会保存字段和类型之间的映射及其他的设置。这种映射具体到毎个映射的每种类型,这也是为什么在</p><p>elasticsearch中，类型有时候也称为映射类型。</p><h2 id="类型" tabindex="-1"><a class="header-anchor" href="#类型" aria-hidden="true">#</a> 类型</h2><p>类型是文档的逻辑容器，就像关系型数据库一样，表格是行的容器。类型中对于字段的定义称为映射，比如name映射为字符串 类型。我们说文档是无模式的，它们不需要拥有映射中所定义的所有字段，比如新増一个字段。那么 elasticsearch是怎么做的呢? elasticsearch会自动的将新字段加入映射，但是这个字段的不确定它是什么类型。elasticsearch就开始猜，如果这个值是18，那么 elasticsearch会认为它是整形。但是 elasticsearch也可能猜不对，所以最安全的方式就是提前定义好所需要的映射，这点跟关系型数据库殊途同归了。先定义好字段，然后再使用，别整什么幺蛾子。</p><h2 id="索引" tabindex="-1"><a class="header-anchor" href="#索引" aria-hidden="true">#</a> 索引</h2><p>就是数据库。</p><p>索引是映射类型的容器，elasticsearch中的索引是一个非常大的文档集合。索引存储了映射类型的字段和其他设置。然后它们被存 储到了各个分片上了。我们来研究下分片是如何工作的。</p><blockquote><p>物理设计：节点和分片如何工作</p></blockquote><figure><img src="'+c+'" alt="image-20210319092101205" tabindex="0" loading="lazy"><figcaption>image-20210319092101205</figcaption></figure><p>一个集群至少有一个节点，而一个节点就是一个elasricsearch进程。节点可以有多个索引默认的，如果你创建索引，那么索引将会有5个分片( primary shard ,又称主分片)构成的。每一个主分片会有一个副本( replica shard ，又称复制分片)。</p><figure><img src="'+i+`" alt="image-20210319091910026" tabindex="0" loading="lazy"><figcaption>image-20210319091910026</figcaption></figure><p>上图是一个有3个节点的集群,可以看到主分片和对应的复制分片都不会在同一个节点内。这样有利于某个节点挂掉了，数据也不至于丢失。实际上，一个分片是一个Lucene索引，一个包含<strong>倒排索引</strong>的文件目录。倒排索引的结构使得elasticsearch在不扫描全部文档的情况下，就能告诉你哪些文档包含特定的关键字。不过，等等，倒排索引是什么鬼？</p><h2 id="倒排索引" tabindex="-1"><a class="header-anchor" href="#倒排索引" aria-hidden="true">#</a> 倒排索引</h2><p>elasticsearch使用的是一种称为倒排索引的结构 ，采用<strong>Lucene倒排索引</strong>作为底层。这种结构适用于快速的全文搜索，一个索引由文档中所有不重复的列表构成。对于每一个词，都有一个包含它的文档列表。例如，现在有两个文档，每个文档包含如下内容:</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>Study every day, good good up to forever<span class="token comment">#文档1包含的内容</span>
To forever,study every day,good good up <span class="token comment">#文档2包含的内容</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>为了创建倒排索引，我们首先要将每个文档拆分成独立的词(或称为词条或者tokens)。然后创建一个包含所有不重复的词条的排序列表，然后列出每个词条出现在哪个文档：</p><table><thead><tr><th>term</th><th>doc_1</th><th>doc_2</th></tr></thead><tbody><tr><td>Study</td><td>√</td><td>×</td></tr><tr><td>To</td><td>×</td><td>×</td></tr><tr><td>every</td><td>√</td><td>√</td></tr><tr><td>forever</td><td>√</td><td>√</td></tr><tr><td>day</td><td>√</td><td>√</td></tr><tr><td>study</td><td>x</td><td>√</td></tr><tr><td>good</td><td>√</td><td>√</td></tr><tr><td>every</td><td>√</td><td>√</td></tr><tr><td>to</td><td>√</td><td>x</td></tr><tr><td>up</td><td>√</td><td>√</td></tr></tbody></table><p>现在，我们试图搜索to forever，只需要查看包含每个词条的文档：</p><table><thead><tr><th>term</th><th>doc_1</th><th>doc_2</th></tr></thead><tbody><tr><td>to</td><td>√</td><td>x</td></tr><tr><td>forever</td><td>√</td><td>√</td></tr><tr><td>total</td><td>2</td><td>1</td></tr></tbody></table><p>两个文档都匹配，但是第一个文档比第二个匹配程度更高。如果没有别的条件，现在这两个包含关键字的文档都将返回。</p><p>再来看一个示例，比如我们通过博客标签来搜索博客文章。那么倒排索引列表就是这样的一个结构：</p><figure><img src="`+s+'" alt="image-20210319092346121" tabindex="0" loading="lazy"><figcaption>image-20210319092346121</figcaption></figure><p>如果要搜索含有python标签的文章，那相对于查找所有原始数据而言，查找倒排索引后的数据将会快的多。只需要查看标签这一栏，然后获取相关的文章ID即可。</p><p><mark>倒排索引，英文原名Inverted index。一个未经处理的数据库中，一般是以文档ID作为索引，以文档内容作为记录。而Inverted index 指的是将单词或记录作为索引，将文档ID作为记录，这样便可以方便地通过单词或记录查找到其所在的文档。</mark></p><blockquote><p>elasticsearch的索引和Lucene的索引对比</p></blockquote><p>在elasticsearch中，索引（库）这个词被频繁使用。这就是术语的使用。elasticsearch中索引被分为多个分片，每份分片是一个Lucene的索引。所以一个elasticsearch索引是由多个Lucene索引组成的。别问为什么，谁让elasticsearch使用Lucene作为底层呢。如无特指,说起索引都是指elasticsearch的索引。</p><blockquote><p>接下来的一切操作都在kibana中Dev Tools下的Console里完成。基础操作。</p></blockquote>',43),n=[l];function h(p,g){return e(),a("div",null,n)}const m=t(o,[["render",h],["__file","06.ES核心概念.html.vue"]]);export{m as default};
