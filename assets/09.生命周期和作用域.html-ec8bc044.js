import{_ as e,V as s,W as a,X as o}from"./framework-a569e214.js";const r={},i=o('<h2 id="" tabindex="-1"><a class="header-anchor" href="#" aria-hidden="true">#</a></h2><blockquote><p>不同作用域和生命周期类别是至关重要的，因为错误的使用会导致非常严重的<mark>并发问题</mark>。</p></blockquote><h3 id="_1、sqlsessionfactorybuilder" tabindex="-1"><a class="header-anchor" href="#_1、sqlsessionfactorybuilder" aria-hidden="true">#</a> 1、SqlSessionFactoryBuilder</h3><blockquote><p>这个类可以被实例化、使用和丢弃，<mark>一旦创建了 SqlSessionFactory，就不再需要它了</mark>。 因此 SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是<mark>局部方法变量</mark>）。 你可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory 实例，但最好还是不要一直保留着它，以保证所有的 XML 解析资源可以被释放给更重要的事情。</p></blockquote><h3 id="_2、sqlsessionfactory" tabindex="-1"><a class="header-anchor" href="#_2、sqlsessionfactory" aria-hidden="true">#</a> 2、SqlSessionFactory</h3><blockquote><p>SqlSessionFactory <mark>一旦被创建就应该在应用的运行期间一直存在</mark>，没有任何理由丢弃它或重新创建另一个实例。 使用 SqlSessionFactory 的最佳实践是在应用运行期间不要重复创建多次，多次重建 SqlSessionFactory 被视为一种代码“坏习惯”。因此 SqlSessionFactory 的最佳作用域是<mark>应用作用域</mark>。 有很多方法可以做到，<mark>最简单的就是使用单例模式或者静态单例模式</mark>。</p></blockquote><p>说白了就是数据库连接池。</p><h3 id="_3、sqlsession" tabindex="-1"><a class="header-anchor" href="#_3、sqlsession" aria-hidden="true">#</a> 3、SqlSession</h3><blockquote><p>每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的<mark>最佳的作用域是请求或方法作用域</mark>。 绝对不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。 也绝不能将 SqlSession 实例的引用放在任何类型的托管作用域中，比如 Servlet 框架中的 HttpSession。 如果你现在正在使用一种 Web 框架，考虑将 SqlSession 放在一个和 HTTP 请求相似的作用域中。 换句话说，每次收到 HTTP 请求，就可以打开一个 SqlSession，<mark>返回一个响应后，就关闭它。 这个关闭操作很重要</mark>，为了确保每次都能执行关闭操作，你应该把这个关闭操作放到 finally 块中。</p></blockquote><p>可以理解为连接到连接池的一个请求。</p>',10),t=[i];function l(n,c){return s(),a("div",null,t)}const d=e(r,[["render",l],["__file","09.生命周期和作用域.html.vue"]]);export{d as default};
