import{_ as o,V as t,W as r,X as n}from"./framework-a569e214.js";const s={},e=n('<h2 id="并发" tabindex="-1"><a class="header-anchor" href="#并发" aria-hidden="true">#</a> 并发</h2><blockquote><p><strong>多个线程</strong>操作<strong>同一个资源</strong>。</p></blockquote><blockquote><p>并发：<strong>同一个对象</strong>被<strong>多个线程</strong><mark>同时操作</mark>。比如：上万人同时抢100张票、两个银行同时取钱等。</p></blockquote><ul><li><p>现实生活中我们会遇到”<strong>同一个资源,多个人都想使用</strong>“的问题。比如食堂排队打饭，每个人都想吃饭，最天然的解决办法就是<strong>排队</strong>。一个个来。</p></li><li><p>处理多线程问题时，多个线程访问同一个对象，并且某些线程还想修改这个对象。这时候我们就需要<strong>线程同步</strong>。线程同步其实就是一种<strong>等待机制，<strong>多个需要同时访问此对象的线程进入这个</strong>对象的等待池</strong>形成队列，等待前面线程使用完毕，下一个线程再使用。</p></li></ul><h2 id="队列和锁" tabindex="-1"><a class="header-anchor" href="#队列和锁" aria-hidden="true">#</a> 队列和锁</h2><blockquote><p>形成条件：队列 + 锁</p></blockquote><h2 id="线程同步" tabindex="-1"><a class="header-anchor" href="#线程同步" aria-hidden="true">#</a> 线程同步</h2><blockquote><p>由于同一进程的多个线程共享<strong>同一块存储空间</strong>，在带来方便的同时，也带来了访问冲突问题。为了保证数据在方法中被访问时的正确性，在访问时加入<strong>锁机制</strong>。</p></blockquote><blockquote><p><strong>synchronized</strong> 当一个线程获得对象的<strong>排它锁</strong>，独占资源，<strong>其他线程必须等待</strong>使用后释放锁即可。存在以下问题：</p></blockquote><ul><li>一个线程持有锁会导致其他所有<strong>需要此锁的线程挂起</strong>。</li><li>在多线程竞争下，加锁、释放锁会导致比较多的<strong>上下文切换和调度延时</strong>，引起性能问题。</li><li>如果一个优先级高的线程等待一个优先级低的线程释放锁会导致<strong>优先级倒置</strong>，引起性能问题。</li></ul>',10),a=[e];function l(g,c){return t(),r("div",null,a)}const h=o(s,[["render",l],["__file","20.线程同步机制.html.vue"]]);export{h as default};
