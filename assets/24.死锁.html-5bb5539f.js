const e=JSON.parse('{"key":"v-53e34a7e","path":"/JavaSE/10.%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/24.%E6%AD%BB%E9%94%81.html","title":"死锁","lang":"zh-CN","frontmatter":{"title":"死锁","date":"2022-03-29T15:40:07.000Z","category":["Java","多线程详解"],"description":"多个线程各自占有一些共享资源，并且互相等待其他线程占有的资源才能运行。从而导致两个或者多个线程都在等待对方释放资源，都停止执行的情形。某一个同步块同时拥有两个以上对象的锁时，就可能会发生死锁的问题。 多个线程互相抱着对方需要的资源，然后形成僵持。 测试会发现程序卡死： 修改makeUp()方法： 产生死锁的四个必要条件 互斥条件：一个资源每次只能被一个...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/JavaSE/10.%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/24.%E6%AD%BB%E9%94%81.html"}],["meta",{"property":"og:site_name","content":"真理并无尽头"}],["meta",{"property":"og:title","content":"死锁"}],["meta",{"property":"og:description","content":"多个线程各自占有一些共享资源，并且互相等待其他线程占有的资源才能运行。从而导致两个或者多个线程都在等待对方释放资源，都停止执行的情形。某一个同步块同时拥有两个以上对象的锁时，就可能会发生死锁的问题。 多个线程互相抱着对方需要的资源，然后形成僵持。 测试会发现程序卡死： 修改makeUp()方法： 产生死锁的四个必要条件 互斥条件：一个资源每次只能被一个..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-02-17T17:06:16.000Z"}],["meta",{"property":"article:published_time","content":"2022-03-29T15:40:07.000Z"}],["meta",{"property":"article:modified_time","content":"2023-02-17T17:06:16.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"死锁\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-03-29T15:40:07.000Z\\",\\"dateModified\\":\\"2023-02-17T17:06:16.000Z\\",\\"author\\":[]}"]]},"headers":[],"git":{"createdTime":1676653576000,"updatedTime":1676653576000,"contributors":[{"name":"木叶萧萧","email":"deciphers@163.com","commits":1}]},"readingTime":{"minutes":2.26,"words":678},"filePathRelative":"JavaSE/10.多线程详解/24.死锁.md","localizedDate":"2022年3月29日","autoDesc":true}');export{e as data};
