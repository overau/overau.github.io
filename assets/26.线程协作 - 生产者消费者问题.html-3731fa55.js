import{_ as t,V as o,W as i,X as l}from"./framework-a569e214.js";const e="/img/mult-thread/image-20210310200122187.png",r={},n=l('<p>应用场景：生产者和消费者问题</p><ul><li>假设仓库中只能存放一件产品，生产者将生产出来的产品放入仓库，消费者将仓库中产品取走消费。</li><li>如果仓库中没有产品，则生产者将产品放入仓库，否则停止生产并等待，直到仓库中的产品被消费者取走为止。</li><li>如果仓库中放有产品，则消费者可以将产品取走消费，否则停止消费并等待，直到仓库中再次放入产品为止。</li></ul><figure><img src="'+e+'" alt="image-20210310200122187" tabindex="0" loading="lazy"><figcaption>image-20210310200122187</figcaption></figure><blockquote><p>这是一个线程同步问题：生产者和消费者<strong>共享同一个资源</strong>，并且生产者和消费者之间<strong>相互依赖</strong>，互为条件。</p></blockquote><ul><li>对于生产者，没有生产产品之前，要通知消费者等待。而生产了产品之后，又需要马上通知消费者消费。</li><li>对于消费者，在消费之后，要通知生产者已经结束消费，需要生产新的产品以供消费。</li><li>在生产者消费者问题中，仅有 synchronized是不够的： <ul><li>synchronized可阻止并发更新同一个共享资源，实现了同步。</li><li>synchronized不能用来实现不同线程之间的消息传递(通信)。</li></ul></li></ul><blockquote><p>Java提供了几个方法解决线程之间的通信问题</p></blockquote><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>wait()</td><td>表示线程一直等待，直到其他线程通知，与seep不同。会<strong>释放锁</strong>。</td></tr><tr><td>wait(long timeout)</td><td>指定等待的毫秒数。</td></tr><tr><td>notify()</td><td><strong>唤醒</strong>一个处于<strong>等待状态</strong>的线程。</td></tr><tr><td>notifyAll()</td><td>唤醒同一个对象上<strong>所有调用wait()方法</strong>的线程，优先级比较高的线程优先调度。</td></tr></tbody></table><p>注意：均是 Object类的方法，都只能在<strong>同步方法或者同步代码块</strong>中使用，否则会抛出异常IllegalMonitorState Exception。</p>',8),s=[n];function _(d,a){return o(),i("div",null,s)}const g=t(r,[["render",_],["__file","26.线程协作 - 生产者消费者问题.html.vue"]]);export{g as default};
