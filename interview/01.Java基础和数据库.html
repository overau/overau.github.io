<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.60" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://vuepress-theme-hope-docs-demo.netlify.app/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html"><meta property="og:site_name" content="真理并无尽头"><meta property="og:title" content="Java基础和数据库"><meta property="og:description" content="01.什么是字节码?采用字节码的好处是什么? 在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。; 由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。跨平台。; 02.== 和 equals() 的区别 == 对于基本类..."><meta property="og:type" content="article"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2023-03-01T07:12:28.000Z"><meta property="article:modified_time" content="2023-03-01T07:12:28.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"Java基础和数据库","image":[""],"dateModified":"2023-03-01T07:12:28.000Z","author":[]}</script><link rel="icon" href="/logo.svg"><title>Java基础和数据库 | 真理并无尽头</title><meta name="description" content="01.什么是字节码?采用字节码的好处是什么? 在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。; 由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。跨平台。; 02.== 和 equals() 的区别 == 对于基本类...">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d2025;
      }

      html,
      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="preload" href="/assets/style-255b3d65.css" as="style"><link rel="stylesheet" href="/assets/style-255b3d65.css">
    <link rel="modulepreload" href="/assets/app-00bd0cef.js"><link rel="modulepreload" href="/assets/framework-a569e214.js"><link rel="modulepreload" href="/assets/01.Java基础和数据库.html-df95f58f.js"><link rel="modulepreload" href="/assets/01.Java基础和数据库.html-9ec76512.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container has-toc"><!--[--><!--[--><header class="navbar"><div class="navbar-left"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><a href="/" class="brand"><img class="logo" src="/logo.svg" alt="真理并无尽头"><!----><span class="site-name hide-in-pad">真理并无尽头</span></a><!--[--><!----><!--]--></div><div class="navbar-center"><!--[--><!----><!--]--><nav class="nav-links"><div class="nav-item hide-in-mobile"><a href="/" class="nav-link" aria-label="项目主页"><span class="font-icon icon iconfont icon-home" style=""></span>项目主页<!----></a></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="JavaSE"><span class="title"><span class="font-icon icon iconfont icon-launch" style=""></span>JavaSE</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/JavaSE/" class="nav-link" aria-label="面向对象"><span class="font-icon icon iconfont icon-creative" style=""></span>面向对象<!----></a></li><li class="dropdown-item"><a href="/JavaSE/1" class="nav-link" aria-label="常用API"><span class="font-icon icon iconfont icon-creative" style=""></span>常用API<!----></a></li><li class="dropdown-item"><a href="/JavaSE/1" class="nav-link" aria-label="Java异常"><span class="font-icon icon iconfont icon-creative" style=""></span>Java异常<!----></a></li><li class="dropdown-item"><a href="/JavaSE/1" class="nav-link" aria-label="泛型和枚举"><span class="font-icon icon iconfont icon-creative" style=""></span>泛型和枚举<!----></a></li><li class="dropdown-item"><a href="/JavaSE/05.%E9%9B%86%E5%90%88/00.%E9%9B%86%E5%90%88%E7%9A%84%E6%A6%82%E5%BF%B5.html" class="nav-link" aria-label="集合框架"><span class="font-icon icon iconfont icon-creative" style=""></span>集合框架<!----></a></li><li class="dropdown-item"><a href="/JavaSE/06.IO%E6%B5%81/00.%E6%A6%82%E8%BF%B0.html" class="nav-link" aria-label="IO流"><span class="font-icon icon iconfont icon-creative" style=""></span>IO流<!----></a></li><li class="dropdown-item"><a href="/JavaSE/07.%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/01.%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%A8%E8%A7%A3.html" class="nav-link" aria-label="注解和反射"><span class="font-icon icon iconfont icon-creative" style=""></span>注解和反射<!----></a></li><li class="dropdown-item"><a href="/JavaSE/1" class="nav-link" aria-label="网络编程"><span class="font-icon icon iconfont icon-creative" style=""></span>网络编程<!----></a></li><li class="dropdown-item"><a href="/JavaSE/1" class="nav-link" aria-label="NIO"><span class="font-icon icon iconfont icon-creative" style=""></span>NIO<!----></a></li><li class="dropdown-item"><a href="/JavaSE/10.%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/01.%E7%BA%BF%E7%A8%8B%E3%80%81%E8%BF%9B%E7%A8%8B%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B.html" class="nav-link" aria-label="多线程详解"><span class="font-icon icon iconfont icon-creative" style=""></span>多线程详解<!----></a></li><li class="dropdown-item"><a href="/JavaSE/11.JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/01.%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9B%9E%E9%A1%BE.html" class="nav-link" aria-label="JUC并发编程"><span class="font-icon icon iconfont icon-creative" style=""></span>JUC并发编程<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="函数式编程"><span class="title"><span class="font-icon icon iconfont icon-app" style=""></span>函数式编程</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/functional/01.Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/01.%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3.html" class="nav-link" aria-label="Lambda表达式"><span class="font-icon icon iconfont icon-creative" style=""></span>Lambda表达式<!----></a></li><li class="dropdown-item"><a href="/functional/02.stream%E6%B5%81/01.stream%E6%B5%81%E6%A6%82%E8%BF%B0.html" class="nav-link" aria-label="stream流"><span class="font-icon icon iconfont icon-creative" style=""></span>stream流<!----></a></li><li class="dropdown-item"><a href="/functional/03.Optional/01.Optional%E6%A6%82%E8%BF%B0.html" class="nav-link" aria-label="Optional"><span class="font-icon icon iconfont icon-creative" style=""></span>Optional<!----></a></li><li class="dropdown-item"><a href="/functional/04.%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/01.%E6%A6%82%E8%BF%B0.html" class="nav-link" aria-label="函数式接口"><span class="font-icon icon iconfont icon-creative" style=""></span>函数式接口<!----></a></li><li class="dropdown-item"><a href="/functional/05.%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/01.%E6%8E%A8%E8%8D%90%E7%94%A8%E6%B3%95.html" class="nav-link" aria-label="方法引用"><span class="font-icon icon iconfont icon-creative" style=""></span>方法引用<!----></a></li><li class="dropdown-item"><a href="/functional/06.%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/01.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BC%98%E5%8C%96.html" class="nav-link" aria-label="高级用法"><span class="font-icon icon iconfont icon-creative" style=""></span>高级用法<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="数据库技术"><span class="title"><span class="font-icon icon iconfont icon-discover" style=""></span>数据库技术</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/database/01.MySQL" class="nav-link" aria-label="MySQL"><span class="font-icon icon iconfont icon-creative" style=""></span>MySQL<!----></a></li><li class="dropdown-item"><a href="/database/02.JDBC/01.JDBC%E6%A6%82%E8%BF%B0.html" class="nav-link" aria-label="JDBC"><span class="font-icon icon iconfont icon-creative" style=""></span>JDBC<!----></a></li><li class="dropdown-item"><a href="/database/03.Mybatis/01.%E4%BB%80%E4%B9%88%E6%98%AFMybatis.html" class="nav-link" aria-label="Mybatis"><span class="font-icon icon iconfont icon-creative" style=""></span>Mybatis<!----></a></li><li class="dropdown-item"><a href="/database/06.MybatisPlus" class="nav-link" aria-label="MybatisPlus"><span class="font-icon icon iconfont icon-creative" style=""></span>MybatisPlus<!----></a></li><li class="dropdown-item"><a href="/database/04.Redis/01.%E8%AF%BE%E7%A8%8B%E6%A6%82%E8%BF%B0.html" class="nav-link" aria-label="Redis"><span class="font-icon icon iconfont icon-creative" style=""></span>Redis<!----></a></li><li class="dropdown-item"><a href="/database/05.ElasticSearch/00.%E8%AF%BE%E7%A8%8B%E6%A6%82%E8%A7%88.html" class="nav-link" aria-label="ElasticSearch"><span class="font-icon icon iconfont icon-creative" style=""></span>ElasticSearch<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="Spring全家桶"><span class="title"><span class="font-icon icon iconfont icon-hot" style=""></span>Spring全家桶</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/spring/01.Spring%E5%85%A5%E9%97%A8/01.%E7%AE%80%E4%BB%8B.html" class="nav-link" aria-label="Spring入门"><span class="font-icon icon iconfont icon-creative" style=""></span>Spring入门<!----></a></li><li class="dropdown-item"><a href="/spring/02.SpringBoot%E7%B2%BE%E8%AE%B2%E7%BB%86%E8%AE%B2/01.%E5%86%85%E5%B5%8CTomcat%E6%95%B4%E5%90%88SpringMVC.html" class="nav-link" aria-label="SpringBoot精讲细讲"><span class="font-icon icon iconfont icon-creative" style=""></span>SpringBoot精讲细讲<!----></a></li><li class="dropdown-item"><a href="/spring/03.SpringSecurity%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%83/00.%E7%AE%80%E4%BB%8B.html" class="nav-link" aria-label="SpringSecurity认证授权"><span class="font-icon icon iconfont icon-creative" style=""></span>SpringSecurity认证授权<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="源码分析"><span class="title"><span class="font-icon icon iconfont icon-load" style=""></span>源码分析</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/source-code/01.Mybatis/01.Mybatis%E6%89%A7%E8%A1%8C%E5%99%A8.html" class="nav-link" aria-label="Mybatis源码解析"><span class="font-icon icon iconfont icon-load" style=""></span>Mybatis源码解析<!----></a></li><li class="dropdown-item"><a href="/source-code/02.Spring/01.Spring%E5%AE%B9%E5%99%A8%E4%B8%ADBean%E7%9A%84%E5%88%9B%E5%BB%BA.html" class="nav-link" aria-label="Spring源码解析"><span class="font-icon icon iconfont icon-leaf" style=""></span>Spring源码解析<!----></a></li><li class="dropdown-item"><a href="/source-code/03.SpringBoot/01.SpringBoot%E5%AE%B9%E5%99%A8%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E8%8E%B7%E5%8F%96.html" class="nav-link" aria-label="SpringBoot源码解析"><span class="font-icon icon iconfont icon-hot" style=""></span>SpringBoot源码解析<!----></a></li><li class="dropdown-item"><a href="/source-code/04.bean/00.%E6%B3%A8%E5%85%A5bean%E7%9A%84%E6%96%B9%E5%BC%8F.html" class="nav-link" aria-label="bean的注入探究"><span class="font-icon icon iconfont icon-advance" style=""></span>bean的注入探究<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="项目实战"><span class="title"><span class="font-icon icon iconfont icon-operate" style=""></span>项目实战</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/do-project/Blog/01.%E5%8D%9A%E5%AE%A2%E5%8A%9F%E8%83%BD%E9%9C%80%E6%B1%82.html" class="nav-link" aria-label="前后端分离博客"><span class="font-icon icon iconfont icon-creative" style=""></span>前后端分离博客<!----></a></li><li class="dropdown-item"><a href="/do-project/Redis/01.%E7%9F%AD%E4%BF%A1%E7%99%BB%E5%BD%95.html" class="nav-link" aria-label="Redis项目实战"><span class="font-icon icon iconfont icon-creative" style=""></span>Redis项目实战<!----></a></li><li class="dropdown-item"><a href="/do-project/Reggie/01.%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html" class="nav-link" aria-label="瑞吉外卖"><span class="font-icon icon iconfont icon-creative" style=""></span>瑞吉外卖<!----></a></li><li class="dropdown-item"><a href="/do-project/ReggiePerf/01.%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96.html" class="nav-link" aria-label="瑞吉外卖优化篇"><span class="font-icon icon iconfont icon-creative" style=""></span>瑞吉外卖优化篇<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="开源项目"><span class="title"><span class="font-icon icon iconfont icon-github" style=""></span>开源项目</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/open-project/ruoyi" class="nav-link" aria-label="若依分离版"><span class="font-icon icon iconfont icon-creative" style=""></span>若依分离版<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html" class="router-link-active router-link-exact-active nav-link active" aria-label="面试汇总"><span class="font-icon icon iconfont icon-config" style=""></span>面试汇总<!----></a></div><div class="nav-item hide-in-mobile"><a href="/environment/01.Java%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE.html" class="nav-link" aria-label="环境配置"><span class="font-icon icon iconfont icon-config" style=""></span>环境配置<!----></a></div></nav><!--[--><!----><!--]--></div><div class="navbar-right"><!--[--><!----><!--]--><!----><div class="nav-item"><a class="repo-link" href="https://github.com/overau" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button class="outlook-button" tabindex="-1" ariahidden="true"><svg xmlns="http://www.w3.org/2000/svg" class="icon outlook-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="outlook icon"><path d="M224 800c0 9.6 3.2 44.8 6.4 54.4 6.4 48-48 76.8-48 76.8s80 41.6 147.2 0 134.4-134.4 38.4-195.2c-22.4-12.8-41.6-19.2-57.6-19.2C259.2 716.8 227.2 761.6 224 800zM560 675.2l-32 51.2c-51.2 51.2-83.2 32-83.2 32 25.6 67.2 0 112-12.8 128 25.6 6.4 51.2 9.6 80 9.6 54.4 0 102.4-9.6 150.4-32l0 0c3.2 0 3.2-3.2 3.2-3.2 22.4-16 12.8-35.2 6.4-44.8-9.6-12.8-12.8-25.6-12.8-41.6 0-54.4 60.8-99.2 137.6-99.2 6.4 0 12.8 0 22.4 0 12.8 0 38.4 9.6 48-25.6 0-3.2 0-3.2 3.2-6.4 0-3.2 3.2-6.4 3.2-6.4 6.4-16 6.4-16 6.4-19.2 9.6-35.2 16-73.6 16-115.2 0-105.6-41.6-198.4-108.8-268.8C704 396.8 560 675.2 560 675.2zM224 419.2c0-28.8 22.4-51.2 51.2-51.2 28.8 0 51.2 22.4 51.2 51.2 0 28.8-22.4 51.2-51.2 51.2C246.4 470.4 224 448 224 419.2zM320 284.8c0-22.4 19.2-41.6 41.6-41.6 22.4 0 41.6 19.2 41.6 41.6 0 22.4-19.2 41.6-41.6 41.6C339.2 326.4 320 307.2 320 284.8zM457.6 208c0-12.8 12.8-25.6 25.6-25.6 12.8 0 25.6 12.8 25.6 25.6 0 12.8-12.8 25.6-25.6 25.6C470.4 233.6 457.6 220.8 457.6 208zM128 505.6C128 592 153.6 672 201.6 736c28.8-60.8 112-60.8 124.8-60.8-16-51.2 16-99.2 16-99.2l316.8-422.4c-48-19.2-99.2-32-150.4-32C297.6 118.4 128 291.2 128 505.6zM764.8 86.4c-22.4 19.2-390.4 518.4-390.4 518.4-22.4 28.8-12.8 76.8 22.4 99.2l9.6 6.4c35.2 22.4 80 12.8 99.2-25.6 0 0 6.4-12.8 9.6-19.2 54.4-105.6 275.2-524.8 288-553.6 6.4-19.2-3.2-32-19.2-32C777.6 76.8 771.2 80 764.8 86.4z"></path></svg><div class="outlook-dropdown"><!----></div></button></div><!--[--><button class="search-pro-button" role="search" aria-label="搜索"><svg xmlns="http://www.w3.org/2000/svg" class="icon search-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="search icon"><path d="M192 480a256 256 0 1 1 512 0 256 256 0 0 1-512 0m631.776 362.496-143.2-143.168A318.464 318.464 0 0 0 768 480c0-176.736-143.264-320-320-320S128 303.264 128 480s143.264 320 320 320a318.016 318.016 0 0 0 184.16-58.592l146.336 146.368c12.512 12.48 32.768 12.48 45.28 0 12.48-12.512 12.48-32.768 0-45.28"></path></svg></button><!--]--><!--[--><!----><!--]--><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow left"></span></div><aside class="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><!--[--><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html" class="router-link-active router-link-exact-active nav-link active sidebar-link sidebar-page active" aria-label="Java基础和数据库"><!---->Java基础和数据库<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_01-什么是字节码-采用字节码的好处是什么" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="01.什么是字节码?采用字节码的好处是什么?"><!---->01.什么是字节码?采用字节码的好处是什么?<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_02-和-equals-的区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="02.== 和 equals() 的区别"><!---->02.== 和 equals() 的区别<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_03-hashcode-与-equals" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="03.hashCode() 与 equals()"><!---->03.hashCode() 与 equals()<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#hashcode-有什么用" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="hashCode() 有什么用？"><!---->hashCode() 有什么用？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#为什么重写-equals-时必须重写-hashcode-方法" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="为什么重写 equals() 时必须重写 hashCode() 方法？"><!---->为什么重写 equals() 时必须重写 hashCode() 方法？<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_04-包装类型的常量池技术了解么" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="04.包装类型的常量池技术了解么？"><!---->04.包装类型的常量池技术了解么？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_05-自动装箱与拆箱了解吗-原理是什么" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="05.自动装箱与拆箱了解吗？原理是什么？"><!---->05.自动装箱与拆箱了解吗？原理是什么？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_06-面向对象三大特征" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="06.面向对象三大特征"><!---->06.面向对象三大特征<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_07-接口和抽象类有什么共同点和区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="07.接口和抽象类有什么共同点和区别？"><!---->07.接口和抽象类有什么共同点和区别？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_08-深拷贝和浅拷贝区别了解吗-什么是引用拷贝" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="08.深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"><!---->08.深拷贝和浅拷贝区别了解吗？什么是引用拷贝？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_09-java-常见对象" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="09.Java 常见对象"><!---->09.Java 常见对象<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#object" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Object"><!---->Object<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#string" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="String"><!---->String<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_10-泛型" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="10.泛型"><!---->10.泛型<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_11-反射" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="11.反射"><!---->11.反射<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_12-注解" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="12.注解"><!---->12.注解<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_13-异常" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="13.异常"><!---->13.异常<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_14-i-o" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="14.I/O"><!---->14.I/O<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_15-为什么-java-中只有值传递" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="15.为什么 Java 中只有值传递？"><!---->15.为什么 Java 中只有值传递？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_16-集合框架底层数据结构总结" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="16.集合框架底层数据结构总结"><!---->16.集合框架底层数据结构总结<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_17-为什么要使用集合" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="17.为什么要使用集合？"><!---->17.为什么要使用集合？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_18-collection-子接口之-list" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="18.Collection 子接口之 List"><!---->18.Collection 子接口之 List<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_19-arraylist-与-linkedlist-区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="19.Arraylist 与 LinkedList 区别?"><!---->19.Arraylist 与 LinkedList 区别?<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_20-arraylist-的扩容机制" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="20.ArrayList 的扩容机制"><!---->20.ArrayList 的扩容机制<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_21-comparable-和-comparator-的区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="21.comparable 和 Comparator 的区别"><!---->21.comparable 和 Comparator 的区别<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_22-无序性和不可重复性的含义是什么" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="22.无序性和不可重复性的含义是什么"><!---->22.无序性和不可重复性的含义是什么<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_23-比较-hashset、linkedhashset-和-treeset-三者的异同" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="23.比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同"><!---->23.比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_24-hashmap-和-hashset-区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="24.HashMap 和 HashSet 区别"><!---->24.HashMap 和 HashSet 区别<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_25-hashset-如何检查重复" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="25.HashSet 如何检查重复"><!---->25.HashSet 如何检查重复<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_26-hashmap-的底层实现" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="26.HashMap 的底层实现"><!---->26.HashMap 的底层实现<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_27-hashmap-的长度为什么是-2-的幂次方" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="27.HashMap 的长度为什么是 2 的幂次方"><!---->27.HashMap 的长度为什么是 2 的幂次方<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_28-hashmap-多线程操作导致死循环问题" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="28.HashMap 多线程操作导致死循环问题"><!---->28.HashMap 多线程操作导致死循环问题<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_29-hashmap-有哪几种常见的遍历方式" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="29.HashMap 有哪几种常见的遍历方式?"><!---->29.HashMap 有哪几种常见的遍历方式?<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_30-concurrenthashmap-和-hashtable-的区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="30.ConcurrentHashMap 和 Hashtable 的区别"><!---->30.ConcurrentHashMap 和 Hashtable 的区别<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_31-collections-工具类常用方法" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="31.Collections 工具类常用方法"><!---->31.Collections 工具类常用方法<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_32-请简要描述线程与进程的关系-区别及优缺点" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="32.请简要描述线程与进程的关系,区别及优缺点？"><!---->32.请简要描述线程与进程的关系,区别及优缺点？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_33-为什么要使用多线程呢" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="33.为什么要使用多线程呢?"><!---->33.为什么要使用多线程呢?<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_34-使用多线程可能带来什么问题" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="34.使用多线程可能带来什么问题?"><!---->34.使用多线程可能带来什么问题?<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_35-说说线程的生命周期和状态" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="35.说说线程的生命周期和状态?"><!---->35.说说线程的生命周期和状态?<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_36-什么是上下文切换" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="36.什么是上下文切换?"><!---->36.什么是上下文切换?<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_37-什么是线程死锁-如何避免死锁" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="37.什么是线程死锁?如何避免死锁?"><!---->37.什么是线程死锁?如何避免死锁?<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_38-说说-sleep-方法和-wait-方法区别和共同点" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="38.说说 sleep() 方法和 wait() 方法区别和共同点?"><!---->38.说说 sleep() 方法和 wait() 方法区别和共同点?<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_39-为什么我们调用-start-方法时会执行-run-方法-为什么我们不能直接调用-run-方法" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="39.为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？"><!---->39.为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_40-说一说自己对于-synchronized-关键字的了解" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="40.说一说自己对于 synchronized 关键字的了解"><!---->40.说一说自己对于 synchronized 关键字的了解<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_41-说说自己是怎么使用-synchronized-关键字" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="41.说说自己是怎么使用 synchronized 关键字"><!---->41.说说自己是怎么使用 synchronized 关键字<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_42-构造方法可以使用-synchronized-关键字修饰么" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="42.构造方法可以使用 synchronized 关键字修饰么？"><!---->42.构造方法可以使用 synchronized 关键字修饰么？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_43-讲一下-synchronized-关键字的底层原理" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="43.讲一下 synchronized 关键字的底层原理"><!---->43.讲一下 synchronized 关键字的底层原理<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_44-说说-jdk1-6-之后的-synchronized-关键字底层做了哪些优化-可以详细介绍一下这些优化吗" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="44.说说 JDK1.6 之后的 synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗"><!---->44.说说 JDK1.6 之后的 synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_45-谈谈-synchronized-和-reentrantlock-的区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="45.谈谈 synchronized 和 ReentrantLock 的区别"><!---->45.谈谈 synchronized 和 ReentrantLock 的区别<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_46-cpu-缓存模型" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="46.CPU 缓存模型"><!---->46.CPU 缓存模型<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_47-讲一下-jmm-java-内存模型" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="47.讲一下 JMM(Java 内存模型)"><!---->47.讲一下 JMM(Java 内存模型)<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_48-并发编程的三个重要特性" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="48.并发编程的三个重要特性"><!---->48.并发编程的三个重要特性<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_49-说说-synchronized-关键字和-volatile-关键字的区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="49.说说 synchronized 关键字和 volatile 关键字的区别"><!---->49.说说 synchronized 关键字和 volatile 关键字的区别<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_50-threadlocal" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="50.ThreadLocal"><!---->50.ThreadLocal<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_51-为什么要用线程池" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="51.为什么要用线程池？"><!---->51.为什么要用线程池？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_52-实现-runnable-接口和-callable-接口的区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="52.实现 Runnable 接口和 Callable 接口的区别"><!---->52.实现 Runnable 接口和 Callable 接口的区别<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_53-执行-execute-方法和-submit-方法的区别是什么呢" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="53.执行 execute()方法和 submit()方法的区别是什么呢？"><!---->53.执行 execute()方法和 submit()方法的区别是什么呢？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_54-如何创建线程池" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="54.如何创建线程池"><!---->54.如何创建线程池<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_55-线程池的七个参数" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="55.线程池的七个参数"><!---->55.线程池的七个参数<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_56-cas和aqs" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="56.CAS和AQS"><!---->56.CAS和AQS<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_57-用过-countdownlatch-么-什么场景下用的" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="57.用过 CountDownLatch 么？什么场景下用的？"><!---->57.用过 CountDownLatch 么？什么场景下用的？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_58-介绍下-java-内存区域-运行时数据区" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="58.介绍下 Java 内存区域（运行时数据区）"><!---->58.介绍下 Java 内存区域（运行时数据区）<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_59-对象的创建" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="59.对象的创建"><!---->59.对象的创建<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_60-字符串常量池常见问题" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="60.字符串常量池常见问题"><!---->60.字符串常量池常见问题<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_61-类加载过程" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="61.类加载过程"><!---->61.类加载过程<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#mysql" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="MySQL"><!---->MySQL<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_62-锁机制与-innodb-锁算法" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="62.锁机制与 InnoDB 锁算法"><!---->62.锁机制与 InnoDB 锁算法<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_63-查询缓存" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="63.查询缓存"><!---->63.查询缓存<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_64-何为事务" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="64.何为事务？"><!---->64.何为事务？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_65-何为数据库事务" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="65.何为数据库事务？"><!---->65.何为数据库事务？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_66-何为-acid-特性呢" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="66.何为 ACID 特性呢？"><!---->66.何为 ACID 特性呢？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_67-数据事务的实现原理呢" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="67.数据事务的实现原理呢？"><!---->67.数据事务的实现原理呢？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_68-并发事务带来哪些问题" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="68.并发事务带来哪些问题?"><!---->68.并发事务带来哪些问题?<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_69-事务隔离级别有哪些" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="69.事务隔离级别有哪些?"><!---->69.事务隔离级别有哪些?<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_70-mysql-的默认隔离级别是什么" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="70.MySQL 的默认隔离级别是什么?"><!---->70.MySQL 的默认隔离级别是什么?<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_71-mysql-索引详解" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="71.MySQL 索引详解"><!---->71.MySQL 索引详解<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#何为索引-有什么作用" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="何为索引？有什么作用？"><!---->何为索引？有什么作用？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#索引的优缺点" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="索引的优缺点"><!---->索引的优缺点<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#索引的底层数据结构" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="索引的底层数据结构"><!---->索引的底层数据结构<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#索引类型" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="索引类型"><!---->索引类型<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#explain的用法" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="explain的用法"><!---->explain的用法<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#使用索引的问题" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="使用索引的问题"><!---->使用索引的问题<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#redis" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Redis"><!---->Redis<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_72-什么是-redis" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="72.什么是 Redis？"><!---->72.什么是 Redis？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_73-redis-为什么这么快" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="73.Redis 为什么这么快？"><!---->73.Redis 为什么这么快？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_74-redis-除了做缓存-还能做什么" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="74.Redis 除了做缓存，还能做什么？"><!---->74.Redis 除了做缓存，还能做什么？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_75-redis-数据结构" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="75.Redis 数据结构"><!---->75.Redis 数据结构<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_76-redis-线程模型" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="76.Redis 线程模型"><!---->76.Redis 线程模型<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_77-redis-内存管理" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="77.Redis 内存管理"><!---->77.Redis 内存管理<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_78-redis-持久化机制" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="78.Redis 持久化机制"><!---->78.Redis 持久化机制<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_79-缓存问题" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="79.缓存问题"><!---->79.缓存问题<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#缓存穿透" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="缓存穿透"><!---->缓存穿透<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#缓存雪崩" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="缓存雪崩"><!---->缓存雪崩<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_80-3种常用的缓存读写策略" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="80.3种常用的缓存读写策略"><!---->80.3种常用的缓存读写策略<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#cache-aside-pattern-旁路缓存模式" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Cache Aside Pattern（旁路缓存模式）"><!---->Cache Aside Pattern（旁路缓存模式）<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#read-write-through-pattern-读写穿透" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Read/Write Through Pattern（读写穿透）"><!---->Read/Write Through Pattern（读写穿透）<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#write-behind-pattern-异步缓存写入" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Write Behind Pattern（异步缓存写入）"><!---->Write Behind Pattern（异步缓存写入）<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_81-redis-内存碎片" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="81.Redis 内存碎片"><!---->81.Redis 内存碎片<!----></a><ul class="sidebar-sub-headers"></ul></li></ul><!--]--></li><li><!--[--><a href="/interview/02.%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6.html" class="nav-link sidebar-link sidebar-page" aria-label="常用框架"><!---->常用框架<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/03.10k%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95.html" class="nav-link sidebar-link sidebar-page" aria-label="10k模拟面试"><!---->10k模拟面试<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><!---->Java基础和数据库</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="https://gitee.com/overau" target="_blank" rel="noopener noreferrer">HeJin</a></span><span property="author" content="HeJin"></span></span><!----><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span><!----></span><meta property="datePublished" content="2023-03-01T07:12:28.000Z"></span><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 68 分钟</span><meta property="timeRequired" content="PT68M"></span><!----><!----></div><hr></div><div class="toc-place-holder"><aside id="toc"><div class="toc-header">此页内容</div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_01-什么是字节码-采用字节码的好处是什么" class="router-link-active router-link-exact-active toc-link level2">01.什么是字节码?采用字节码的好处是什么?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_02-和-equals-的区别" class="router-link-active router-link-exact-active toc-link level2">02.== 和 equals() 的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_03-hashcode-与-equals" class="router-link-active router-link-exact-active toc-link level2">03.hashCode() 与 equals()</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#hashcode-有什么用" class="router-link-active router-link-exact-active toc-link level3">hashCode() 有什么用？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#为什么重写-equals-时必须重写-hashcode-方法" class="router-link-active router-link-exact-active toc-link level3">为什么重写 equals() 时必须重写 hashCode() 方法？</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_04-包装类型的常量池技术了解么" class="router-link-active router-link-exact-active toc-link level2">04.包装类型的常量池技术了解么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_05-自动装箱与拆箱了解吗-原理是什么" class="router-link-active router-link-exact-active toc-link level2">05.自动装箱与拆箱了解吗？原理是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_06-面向对象三大特征" class="router-link-active router-link-exact-active toc-link level2">06.面向对象三大特征</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_07-接口和抽象类有什么共同点和区别" class="router-link-active router-link-exact-active toc-link level2">07.接口和抽象类有什么共同点和区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_08-深拷贝和浅拷贝区别了解吗-什么是引用拷贝" class="router-link-active router-link-exact-active toc-link level2">08.深拷贝和浅拷贝区别了解吗？什么是引用拷贝？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_09-java-常见对象" class="router-link-active router-link-exact-active toc-link level2">09.Java 常见对象</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#object" class="router-link-active router-link-exact-active toc-link level3">Object</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#string" class="router-link-active router-link-exact-active toc-link level3">String</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_10-泛型" class="router-link-active router-link-exact-active toc-link level2">10.泛型</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_11-反射" class="router-link-active router-link-exact-active toc-link level2">11.反射</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_12-注解" class="router-link-active router-link-exact-active toc-link level2">12.注解</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_13-异常" class="router-link-active router-link-exact-active toc-link level2">13.异常</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_14-i-o" class="router-link-active router-link-exact-active toc-link level2">14.I/O</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_15-为什么-java-中只有值传递" class="router-link-active router-link-exact-active toc-link level2">15.为什么 Java 中只有值传递？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_16-集合框架底层数据结构总结" class="router-link-active router-link-exact-active toc-link level2">16.集合框架底层数据结构总结</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_17-为什么要使用集合" class="router-link-active router-link-exact-active toc-link level2">17.为什么要使用集合？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_18-collection-子接口之-list" class="router-link-active router-link-exact-active toc-link level2">18.Collection 子接口之 List</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_19-arraylist-与-linkedlist-区别" class="router-link-active router-link-exact-active toc-link level2">19.Arraylist 与 LinkedList 区别?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_20-arraylist-的扩容机制" class="router-link-active router-link-exact-active toc-link level2">20.ArrayList 的扩容机制</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_21-comparable-和-comparator-的区别" class="router-link-active router-link-exact-active toc-link level2">21.comparable 和 Comparator 的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_22-无序性和不可重复性的含义是什么" class="router-link-active router-link-exact-active toc-link level2">22.无序性和不可重复性的含义是什么</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_23-比较-hashset、linkedhashset-和-treeset-三者的异同" class="router-link-active router-link-exact-active toc-link level2">23.比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_24-hashmap-和-hashset-区别" class="router-link-active router-link-exact-active toc-link level2">24.HashMap 和 HashSet 区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_25-hashset-如何检查重复" class="router-link-active router-link-exact-active toc-link level2">25.HashSet 如何检查重复</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_26-hashmap-的底层实现" class="router-link-active router-link-exact-active toc-link level2">26.HashMap 的底层实现</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_27-hashmap-的长度为什么是-2-的幂次方" class="router-link-active router-link-exact-active toc-link level2">27.HashMap 的长度为什么是 2 的幂次方</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_28-hashmap-多线程操作导致死循环问题" class="router-link-active router-link-exact-active toc-link level2">28.HashMap 多线程操作导致死循环问题</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_29-hashmap-有哪几种常见的遍历方式" class="router-link-active router-link-exact-active toc-link level2">29.HashMap 有哪几种常见的遍历方式?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_30-concurrenthashmap-和-hashtable-的区别" class="router-link-active router-link-exact-active toc-link level2">30.ConcurrentHashMap 和 Hashtable 的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_31-collections-工具类常用方法" class="router-link-active router-link-exact-active toc-link level2">31.Collections 工具类常用方法</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_32-请简要描述线程与进程的关系-区别及优缺点" class="router-link-active router-link-exact-active toc-link level2">32.请简要描述线程与进程的关系,区别及优缺点？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_33-为什么要使用多线程呢" class="router-link-active router-link-exact-active toc-link level2">33.为什么要使用多线程呢?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_34-使用多线程可能带来什么问题" class="router-link-active router-link-exact-active toc-link level2">34.使用多线程可能带来什么问题?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_35-说说线程的生命周期和状态" class="router-link-active router-link-exact-active toc-link level2">35.说说线程的生命周期和状态?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_36-什么是上下文切换" class="router-link-active router-link-exact-active toc-link level2">36.什么是上下文切换?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_37-什么是线程死锁-如何避免死锁" class="router-link-active router-link-exact-active toc-link level2">37.什么是线程死锁?如何避免死锁?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_38-说说-sleep-方法和-wait-方法区别和共同点" class="router-link-active router-link-exact-active toc-link level2">38.说说 sleep() 方法和 wait() 方法区别和共同点?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_39-为什么我们调用-start-方法时会执行-run-方法-为什么我们不能直接调用-run-方法" class="router-link-active router-link-exact-active toc-link level2">39.为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_40-说一说自己对于-synchronized-关键字的了解" class="router-link-active router-link-exact-active toc-link level2">40.说一说自己对于 synchronized 关键字的了解</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_41-说说自己是怎么使用-synchronized-关键字" class="router-link-active router-link-exact-active toc-link level2">41.说说自己是怎么使用 synchronized 关键字</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_42-构造方法可以使用-synchronized-关键字修饰么" class="router-link-active router-link-exact-active toc-link level2">42.构造方法可以使用 synchronized 关键字修饰么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_43-讲一下-synchronized-关键字的底层原理" class="router-link-active router-link-exact-active toc-link level2">43.讲一下 synchronized 关键字的底层原理</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_44-说说-jdk1-6-之后的-synchronized-关键字底层做了哪些优化-可以详细介绍一下这些优化吗" class="router-link-active router-link-exact-active toc-link level2">44.说说 JDK1.6 之后的 synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_45-谈谈-synchronized-和-reentrantlock-的区别" class="router-link-active router-link-exact-active toc-link level2">45.谈谈 synchronized 和 ReentrantLock 的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_46-cpu-缓存模型" class="router-link-active router-link-exact-active toc-link level2">46.CPU 缓存模型</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_47-讲一下-jmm-java-内存模型" class="router-link-active router-link-exact-active toc-link level2">47.讲一下 JMM(Java 内存模型)</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_48-并发编程的三个重要特性" class="router-link-active router-link-exact-active toc-link level2">48.并发编程的三个重要特性</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_49-说说-synchronized-关键字和-volatile-关键字的区别" class="router-link-active router-link-exact-active toc-link level2">49.说说 synchronized 关键字和 volatile 关键字的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_50-threadlocal" class="router-link-active router-link-exact-active toc-link level2">50.ThreadLocal</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_51-为什么要用线程池" class="router-link-active router-link-exact-active toc-link level2">51.为什么要用线程池？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_52-实现-runnable-接口和-callable-接口的区别" class="router-link-active router-link-exact-active toc-link level2">52.实现 Runnable 接口和 Callable 接口的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_53-执行-execute-方法和-submit-方法的区别是什么呢" class="router-link-active router-link-exact-active toc-link level2">53.执行 execute()方法和 submit()方法的区别是什么呢？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_54-如何创建线程池" class="router-link-active router-link-exact-active toc-link level2">54.如何创建线程池</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_55-线程池的七个参数" class="router-link-active router-link-exact-active toc-link level2">55.线程池的七个参数</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_56-cas和aqs" class="router-link-active router-link-exact-active toc-link level2">56.CAS和AQS</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_57-用过-countdownlatch-么-什么场景下用的" class="router-link-active router-link-exact-active toc-link level2">57.用过 CountDownLatch 么？什么场景下用的？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_58-介绍下-java-内存区域-运行时数据区" class="router-link-active router-link-exact-active toc-link level2">58.介绍下 Java 内存区域（运行时数据区）</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_59-对象的创建" class="router-link-active router-link-exact-active toc-link level2">59.对象的创建</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_60-字符串常量池常见问题" class="router-link-active router-link-exact-active toc-link level2">60.字符串常量池常见问题</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_61-类加载过程" class="router-link-active router-link-exact-active toc-link level2">61.类加载过程</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#mysql" class="router-link-active router-link-exact-active toc-link level2">MySQL</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_62-锁机制与-innodb-锁算法" class="router-link-active router-link-exact-active toc-link level2">62.锁机制与 InnoDB 锁算法</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_63-查询缓存" class="router-link-active router-link-exact-active toc-link level2">63.查询缓存</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_64-何为事务" class="router-link-active router-link-exact-active toc-link level2">64.何为事务？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_65-何为数据库事务" class="router-link-active router-link-exact-active toc-link level2">65.何为数据库事务？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_66-何为-acid-特性呢" class="router-link-active router-link-exact-active toc-link level2">66.何为 ACID 特性呢？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_67-数据事务的实现原理呢" class="router-link-active router-link-exact-active toc-link level2">67.数据事务的实现原理呢？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_68-并发事务带来哪些问题" class="router-link-active router-link-exact-active toc-link level2">68.并发事务带来哪些问题?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_69-事务隔离级别有哪些" class="router-link-active router-link-exact-active toc-link level2">69.事务隔离级别有哪些?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_70-mysql-的默认隔离级别是什么" class="router-link-active router-link-exact-active toc-link level2">70.MySQL 的默认隔离级别是什么?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_71-mysql-索引详解" class="router-link-active router-link-exact-active toc-link level2">71.MySQL 索引详解</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#何为索引-有什么作用" class="router-link-active router-link-exact-active toc-link level3">何为索引？有什么作用？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#索引的优缺点" class="router-link-active router-link-exact-active toc-link level3">索引的优缺点</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#索引的底层数据结构" class="router-link-active router-link-exact-active toc-link level3">索引的底层数据结构</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#索引类型" class="router-link-active router-link-exact-active toc-link level3">索引类型</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#explain的用法" class="router-link-active router-link-exact-active toc-link level3">explain的用法</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#使用索引的问题" class="router-link-active router-link-exact-active toc-link level3">使用索引的问题</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#redis" class="router-link-active router-link-exact-active toc-link level2">Redis</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_72-什么是-redis" class="router-link-active router-link-exact-active toc-link level2">72.什么是 Redis？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_73-redis-为什么这么快" class="router-link-active router-link-exact-active toc-link level2">73.Redis 为什么这么快？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_74-redis-除了做缓存-还能做什么" class="router-link-active router-link-exact-active toc-link level2">74.Redis 除了做缓存，还能做什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_75-redis-数据结构" class="router-link-active router-link-exact-active toc-link level2">75.Redis 数据结构</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_76-redis-线程模型" class="router-link-active router-link-exact-active toc-link level2">76.Redis 线程模型</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_77-redis-内存管理" class="router-link-active router-link-exact-active toc-link level2">77.Redis 内存管理</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_78-redis-持久化机制" class="router-link-active router-link-exact-active toc-link level2">78.Redis 持久化机制</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_79-缓存问题" class="router-link-active router-link-exact-active toc-link level2">79.缓存问题</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#缓存穿透" class="router-link-active router-link-exact-active toc-link level3">缓存穿透</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#缓存雪崩" class="router-link-active router-link-exact-active toc-link level3">缓存雪崩</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_80-3种常用的缓存读写策略" class="router-link-active router-link-exact-active toc-link level2">80.3种常用的缓存读写策略</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#cache-aside-pattern-旁路缓存模式" class="router-link-active router-link-exact-active toc-link level3">Cache Aside Pattern（旁路缓存模式）</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#read-write-through-pattern-读写穿透" class="router-link-active router-link-exact-active toc-link level3">Read/Write Through Pattern（读写穿透）</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#write-behind-pattern-异步缓存写入" class="router-link-active router-link-exact-active toc-link level3">Write Behind Pattern（异步缓存写入）</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/01.Java%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93.html#_81-redis-内存碎片" class="router-link-active router-link-exact-active toc-link level2">81.Redis 内存碎片</a></li><!----><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><h1 id="java基础和数据库" tabindex="-1"><a class="header-anchor" href="#java基础和数据库" aria-hidden="true">#</a> Java基础和数据库</h1><h1 id="一、基础" tabindex="-1"><a class="header-anchor" href="#一、基础" aria-hidden="true">#</a> 一、基础</h1><h2 id="_01-什么是字节码-采用字节码的好处是什么" tabindex="-1"><a class="header-anchor" href="#_01-什么是字节码-采用字节码的好处是什么" aria-hidden="true">#</a> 01.什么是字节码?采用字节码的好处是什么?</h2><ul><li>在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，<strong>只面向虚拟机</strong>。</li><li>由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。<strong>跨平台</strong>。</li></ul><h2 id="_02-和-equals-的区别" tabindex="-1"><a class="header-anchor" href="#_02-和-equals-的区别" aria-hidden="true">#</a> 02.== 和 equals() 的区别</h2><ul><li>== 对于基本类型和引用类型的作用效果是不同的： <ul><li>对于基本数据类型来说，== 比较的是值。</li><li>对于引用数据类型来说，== 比较的是对象的内存地址。</li></ul></li><li>equals() 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。equals()方法存在于Object类中，而Object类是所有类的直接或间接父类，因此所有的类都有equals()方法。 <ul><li>类没有重写 equals()方法 ：通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 Object类equals()方法。</li><li>类重写了 equals()方法 ：一般我们都重写 equals()方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。</li></ul></li></ul><h2 id="_03-hashcode-与-equals" tabindex="-1"><a class="header-anchor" href="#_03-hashcode-与-equals" aria-hidden="true">#</a> 03.hashCode() 与 equals()</h2><h3 id="hashcode-有什么用" tabindex="-1"><a class="header-anchor" href="#hashcode-有什么用" aria-hidden="true">#</a> hashCode() 有什么用？</h3><ul><li>hashCode() 的作用是获取哈希码（int 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。</li><li><code>hashCode()</code>定义在 JDK 的 <code>Object</code> 类中，这就意味着 Java 中的任何类都包含有 <code>hashCode()</code> 函数。</li><li>两个对象的<code>hashCode</code> 值相等并不代表两个对象就相等。 <ul><li>如果两个对象的<code>hashCode</code> 值相等，那这两个对象不一定相等（哈希碰撞）。</li><li>如果两个对象的<code>hashCode</code> 值相等并且<code>equals()</code>方法也返回 <code>true</code>，我们才认为这两个对象相等。</li><li>如果两个对象的<code>hashCode</code> 值不相等，我们就可以直接认为这两个对象不相等。</li></ul></li></ul><h3 id="为什么重写-equals-时必须重写-hashcode-方法" tabindex="-1"><a class="header-anchor" href="#为什么重写-equals-时必须重写-hashcode-方法" aria-hidden="true">#</a> 为什么重写 equals() 时必须重写 hashCode() 方法？</h3><ul><li><code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</li><li>两个对象有相同的 <code>hashCode</code> 值，他们也不一定是相等的（哈希碰撞）。</li></ul><blockquote><p>重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话，使用 <code>HashMap</code> 可能会出现什么问题。</p></blockquote><ul><li>HashMap添加数据的时候，会先比较hashCode值和equals。因为HashMap的<strong>key是不允许重复</strong>的。</li><li>如果没有重写<code>hashCode()</code> 方法，就会出现重复的key被添加。</li></ul><h2 id="_04-包装类型的常量池技术了解么" tabindex="-1"><a class="header-anchor" href="#_04-包装类型的常量池技术了解么" aria-hidden="true">#</a> 04.包装类型的常量池技术了解么？</h2><ul><li>Java 基本类型的包装类的大部分都实现了常量池技术。</li><li><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</li><li>如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。</li><li>所有整型包装类对象之间值的比较，全部使用 equals 方法比较。</li></ul><h2 id="_05-自动装箱与拆箱了解吗-原理是什么" tabindex="-1"><a class="header-anchor" href="#_05-自动装箱与拆箱了解吗-原理是什么" aria-hidden="true">#</a> 05.自动装箱与拆箱了解吗？原理是什么？</h2><ul><li>什么是自动拆装箱？ <ul><li>装箱：将基本类型用它们对应的引用类型包装起来。</li><li>拆箱：将包装类型转换为基本数据类型。</li></ul></li><li>装箱其实就是调用了 包装类的<code>valueOf()</code>方法，拆箱其实就是调用了 <code>xxxValue()</code>方法。</li><li>如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。</li></ul><h2 id="_06-面向对象三大特征" tabindex="-1"><a class="header-anchor" href="#_06-面向对象三大特征" aria-hidden="true">#</a> 06.面向对象三大特征</h2><ul><li>封装</li><li>继承</li><li>多态</li></ul><h2 id="_07-接口和抽象类有什么共同点和区别" tabindex="-1"><a class="header-anchor" href="#_07-接口和抽象类有什么共同点和区别" aria-hidden="true">#</a> 07.接口和抽象类有什么共同点和区别？</h2><ul><li>共同点 ： <ul><li>都不能被实例化。</li><li>都可以包含抽象方法。</li><li>都可以有默认实现的方法（Java 8 可以用 default 关键在接口中定义默认方法）。</li></ul></li><li>区别 ： <ul><li>接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。</li><li>抽象类主要用于代码复用，强调的是所属关系（比如说我们抽象了一个发送短信的抽象类，）。</li><li>一个类只能继承一个类，但是可以实现多个接口。</li><li>接口中的成员变量只能是 public static final 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。</li></ul></li></ul><h2 id="_08-深拷贝和浅拷贝区别了解吗-什么是引用拷贝" tabindex="-1"><a class="header-anchor" href="#_08-深拷贝和浅拷贝区别了解吗-什么是引用拷贝" aria-hidden="true">#</a> 08.深拷贝和浅拷贝区别了解吗？什么是引用拷贝？</h2><ul><li>浅拷贝：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</li><li>深拷贝 ：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</li><li>引用拷贝就是两个不同的引用指向同一个对象。</li></ul><h2 id="_09-java-常见对象" tabindex="-1"><a class="header-anchor" href="#_09-java-常见对象" aria-hidden="true">#</a> 09.Java 常见对象</h2><h3 id="object" tabindex="-1"><a class="header-anchor" href="#object" aria-hidden="true">#</a> Object</h3><p>Object 类是一个特殊的类，是所有类的父类。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//native方法，用于返回当前运行时对象的Class对象，使用了final关键字修饰，故不允许子类重写。</span>

<span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//native方法，用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap。</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span><span class="token comment">//用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户比较字符串的值是否相等。</span>

<span class="token keyword">protected</span> <span class="token keyword">native</span> <span class="token class-name">Object</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">CloneNotSupportedException</span><span class="token comment">//naitive方法，用于创建并返回当前对象的一份拷贝。一般情况下，对于任何对象 x，表达式 x.clone() != x 为true，x.clone().getClass() == x.getClass() 为true。Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会发生CloneNotSupportedException异常。</span>

<span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方法。</span>

<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//native方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span>

<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//native方法，并且不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span>

<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token comment">//native方法，并且不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。</span>

<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> <span class="token keyword">int</span> nanos<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token comment">//多了nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。</span>

<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token comment">//跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span>

<span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">finalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token comment">//实例被垃圾回收器回收的时候触发的操作</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="string" tabindex="-1"><a class="header-anchor" href="#string" aria-hidden="true">#</a> String</h3><blockquote><p>String、StringBuffer、StringBuilder 的区别？String 为什么是不可变的?</p></blockquote><p>String 真正不可变有下面几点原因：</p><ul><li>保存字符串的数组被 final 修饰且为私有的，并且String 类没有提供/暴露修改这个字符串的方法。</li><li>String 类被 final 修饰导致其不能被继承，进而避免了子类破坏 String 不可变。</li></ul><p>对于三者使用的总结：</p><ul><li>操作少量的数据: 适用 String。</li><li>单线程操作字符串缓冲区下操作大量数据: 适用 StringBuilder。</li><li>多线程操作字符串缓冲区下操作大量数据: 适用 StringBuffer。</li></ul><blockquote><p>字符串拼接用“+” 还是 StringBuilder?</p></blockquote><ul><li>Java 语言本身并不支持运算符重载，“+”和“+=”是专门为 String 类重载过的运算符，也是 Java 中仅有的两个重载过的元素符。</li><li>对象引用和“+”的字符串拼接方式，实际上是通过 StringBuilder 调用 append() 方法实现的，拼接完成之后调用 toString() 得到一个 String 对象 。</li><li>不过，在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：编译器不会创建单个 StringBuilder 以复用，会导致创建过多的 StringBuilder 对象。</li></ul><blockquote><p>String#equals() 和 Object#equals() 有何区别？</p></blockquote><p><code>String</code> 中的 <code>equals</code> 方法是被重写过的，比较的是 String 字符串的值是否相等。 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址。</p><blockquote><p>字符串常量池的作用了解吗？</p></blockquote><ul><li><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的<strong>重复创建</strong>。</li></ul><h2 id="_10-泛型" tabindex="-1"><a class="header-anchor" href="#_10-泛型" aria-hidden="true">#</a> 10.泛型</h2><blockquote><p>Java 泛型了解么？什么是类型擦除？介绍一下常用的通配符？</p></blockquote><ul><li>泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</li><li>Java 的泛型是伪泛型，因为 Java 在运行期间，所有的泛型信息都会被擦掉，这也就是通常所说类型擦除。</li><li>泛型一般有三种使用方式: 泛型类、泛型接口、泛型方法。</li></ul><h2 id="_11-反射" tabindex="-1"><a class="header-anchor" href="#_11-反射" aria-hidden="true">#</a> 11.反射</h2><blockquote><p>何为反射？</p></blockquote><p>反射之所以被称为框架的灵魂，主要是因为它赋予了我们在运行时分析类以及执行类中方法的能力。通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。</p><blockquote><p>反射机制优缺点</p></blockquote><ul><li>优点 ： 可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利。</li><li>缺点 ：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。</li></ul><blockquote><p>反射的应用场景</p></blockquote><ul><li>框架中也大量使用了动态代理，而动态代理的实现也依赖反射。</li><li>注解的实现也用到了反射。</li></ul><h2 id="_12-注解" tabindex="-1"><a class="header-anchor" href="#_12-注解" aria-hidden="true">#</a> 12.注解</h2><p>注解只有被解析之后才会生效，常见的解析方法有两种：</p><ul><li>编译期直接扫描 ：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用@Override 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。</li><li>运行期通过反射处理 ：像框架中自带的注解(比如 Spring 框架的 @Value 、@Component)都是通过反射来进行处理的。</li></ul><h2 id="_13-异常" tabindex="-1"><a class="header-anchor" href="#_13-异常" aria-hidden="true">#</a> 13.异常</h2><blockquote><p>Exception 和 Error 有什么区别？</p></blockquote><p>在 Java 中，所有的异常都有一个共同的祖先 java.lang 包中的 Throwable 类。Throwable 类有两个重要的子类:</p><ul><li>Exception :程序本身可以处理的异常，可以通过 catch 来进行捕获。Exception 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。</li><li>Error ：Error 属于程序无法处理的错误 ，我们没办法通过 catch 来进行捕获不建议通过catch捕获 。例如Java 虚拟机运行错误（Virtual MachineError）、虚拟机内存不够错误(OutOfMemoryError)、类定义错误（NoClassDefFoundError）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li></ul><blockquote><p>Checked Exception 和 Unchecked Exception 有什么区别？</p></blockquote><ul><li>Checked Exception 即受检查异常，Java 代码在编译过程中，如果受检查异常没有被 catch/throw 处理的话，就没办法通过编译 。</li><li>除了RuntimeException及其子类以外，其他的Exception类及其子类都属于受检查异常 。常见的受检查异常有： IO 相关的异常、ClassNotFoundException 、SQLException...。</li><li>Unchecked Exception 即 不受检查异常 ，Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。RuntimeException 及其子类都统称为非受检查异常。</li></ul><h2 id="_14-i-o" tabindex="-1"><a class="header-anchor" href="#_14-i-o" aria-hidden="true">#</a> 14.I/O</h2><blockquote><p>什么是序列化?什么是反序列化?</p></blockquote><ul><li>序列化： 将数据结构或对象转换成二进制字节流的过程。</li><li>反序列化：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程。</li></ul><blockquote><p>Java 序列化中如果有些字段不想进行序列化，怎么办？</p></blockquote><ul><li>对于不想进行序列化的变量，使用 transient 关键字修饰。</li></ul><blockquote><p>既然有了字节流,为什么还要有字符流?</p></blockquote><ul><li>字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。</li><li>所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</li></ul><h2 id="_15-为什么-java-中只有值传递" tabindex="-1"><a class="header-anchor" href="#_15-为什么-java-中只有值传递" aria-hidden="true">#</a> 15.为什么 Java 中只有值传递？</h2><p>Java 中将实参传递给方法（或函数）的方式是 <strong>值传递</strong> ：</p><ul><li>如果参数是基本类型的话，很简单，传递的就是基本类型的字面量值的拷贝，会创建副本。</li><li>如果参数是引用类型，传递的就是实参所引用的对象在堆中地址值的拷贝，同样也会创建副本。</li></ul><h1 id="二、集合" tabindex="-1"><a class="header-anchor" href="#二、集合" aria-hidden="true">#</a> 二、集合</h1><h2 id="_16-集合框架底层数据结构总结" tabindex="-1"><a class="header-anchor" href="#_16-集合框架底层数据结构总结" aria-hidden="true">#</a> 16.集合框架底层数据结构总结</h2><blockquote><p>List</p></blockquote><ul><li><code>Arraylist</code>： <code>Object[]</code> 数组。</li><li><code>Vector</code>：<code>Object[]</code> 数组。</li><li><code>LinkedList</code>： 双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)。</li></ul><blockquote><p>Set</p></blockquote><ul><li><code>HashSet</code>(无序，唯一): 基于 <code>HashMap</code> 实现的，底层采用 <code>HashMap</code> 来保存元素</li><li><code>LinkedHashSet</code>: <code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，并且其内部是通过 <code>LinkedHashMap</code> 来实现的。有点类似于我们之前说的 <code>LinkedHashMap</code> 其内部是基于 <code>HashMap</code> 实现一样，不过还是有一点点区别的。</li><li><code>TreeSet</code>(有序，唯一): 红黑树(自平衡的排序二叉树)。</li></ul><blockquote><p>Map</p></blockquote><ul><li><code>HashMap</code>： JDK1.8 之前 <code>HashMap</code> 由数组+链表组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</li><li><code>LinkedHashMap</code>： <code>LinkedHashMap</code> 继承自 <code>HashMap</code>，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，<code>LinkedHashMap</code> 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</li><li><code>Hashtable</code>： 数组+链表组成的，数组是 <code>Hashtable</code> 的主体，链表则是主要为了解决哈希冲突而存在的。</li><li><code>TreeMap</code>： 红黑树（自平衡的排序二叉树）。</li></ul><h2 id="_17-为什么要使用集合" tabindex="-1"><a class="header-anchor" href="#_17-为什么要使用集合" aria-hidden="true">#</a> 17.为什么要使用集合？</h2><ul><li>当我们需要保存一组类型相同的数据的时候，我们应该是用一个容器来保存，这个容器就是数组，但是，使用数组存储对象具有一定的弊端， 因为我们在实际开发中，存储的数据的类型是多种多样的，于是，就出现了“集合”，集合同样也是用来存储多个数据的。</li><li>数组的缺点是一旦声明之后，长度就不可变了；同时，声明数组时的数据类型也决定了该数组存储的数据的类型；而且，数组存储的数据是有序的、可重复的，特点单一。 但是集合提高了数据存储的灵活性，Java 集合不仅可以用来存储不同类型不同数量的对象，还可以保存具有映射关系的数据。</li></ul><h2 id="_18-collection-子接口之-list" tabindex="-1"><a class="header-anchor" href="#_18-collection-子接口之-list" aria-hidden="true">#</a> 18.Collection 子接口之 List</h2><blockquote><p>Arraylist 和 Vector 的区别?</p></blockquote><ul><li><code>ArrayList</code> 是 <code>List</code> 的主要实现类，底层使用 <code>Object[ ]</code>存储，适用于频繁的查找工作，线程不安全 ；</li><li><code>Vector</code> 是 <code>List</code> 的古老实现类，底层使用<code>Object[ ]</code> 存储，线程安全的。</li></ul><h2 id="_19-arraylist-与-linkedlist-区别" tabindex="-1"><a class="header-anchor" href="#_19-arraylist-与-linkedlist-区别" aria-hidden="true">#</a> 19.Arraylist 与 LinkedList 区别?</h2><ul><li>是否保证线程安全： ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全。</li><li>底层数据结构： Arraylist 底层使用的是 Object 数组；LinkedList 底层使用的是 双向链表。</li><li>是否支持快速随机访问。</li><li>内存空间占用： ArrayList 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</li></ul><h2 id="_20-arraylist-的扩容机制" tabindex="-1"><a class="header-anchor" href="#_20-arraylist-的扩容机制" aria-hidden="true">#</a> 20.ArrayList 的扩容机制</h2><h2 id="_21-comparable-和-comparator-的区别" tabindex="-1"><a class="header-anchor" href="#_21-comparable-和-comparator-的区别" aria-hidden="true">#</a> 21.comparable 和 Comparator 的区别</h2><ul><li><code>comparable</code> 接口实际上是出自<code>java.lang</code>包 它有一个 <code>compareTo(Object obj)</code>方法用来排序。</li><li><code>comparator</code>接口实际上是出自 java.util 包它有一个<code>compare(Object obj1, Object obj2)</code>方法用来排序。</li></ul><h2 id="_22-无序性和不可重复性的含义是什么" tabindex="-1"><a class="header-anchor" href="#_22-无序性和不可重复性的含义是什么" aria-hidden="true">#</a> 22.无序性和不可重复性的含义是什么</h2><ul><li>什么是无序性？无序性不等于随机性 ，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的哈希值决定的。</li><li>什么是不可重复性？不可重复性是指添加的元素按照 equals()判断时 ，返回 false，需要同时重写 equals()方法和 HashCode()方法。</li></ul><h2 id="_23-比较-hashset、linkedhashset-和-treeset-三者的异同" tabindex="-1"><a class="header-anchor" href="#_23-比较-hashset、linkedhashset-和-treeset-三者的异同" aria-hidden="true">#</a> 23.比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</h2><ul><li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 都是 <code>Set</code> 接口的实现类，都能保证元素唯一，并且都不是线程安全的。</li><li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 的主要区别在于底层数据结构不同。<code>HashSet</code> 的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）。<code>LinkedHashSet</code> 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。<code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</li><li>底层数据结构不同又导致这三者的应用场景不同。<code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景。</li></ul><h2 id="_24-hashmap-和-hashset-区别" tabindex="-1"><a class="header-anchor" href="#_24-hashmap-和-hashset-区别" aria-hidden="true">#</a> 24.HashMap 和 HashSet 区别</h2><p>HashSet 底层就是基于 HashMap 实现的。</p><h2 id="_25-hashset-如何检查重复" tabindex="-1"><a class="header-anchor" href="#_25-hashset-如何检查重复" aria-hidden="true">#</a> 25.HashSet 如何检查重复</h2><p>当你把对象加入<code>HashSet</code>时，<code>HashSet</code> 会先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时也会与其他加入的对象的 <code>hashcode</code> 值作比较，如果没有相符的 <code>hashcode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashcode</code> 值的对象，这时会调用<code>equals()</code>方法来检查 <code>hashcode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让加入操作成功。</p><h2 id="_26-hashmap-的底层实现" tabindex="-1"><a class="header-anchor" href="#_26-hashmap-的底层实现" aria-hidden="true">#</a> 26.HashMap 的底层实现</h2><ul><li>JDK1.8 之前 HashMap 底层是 数组和链表 结合在一起使用也就是 链表散列。</li><li>JDK1.8 之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</li></ul><h2 id="_27-hashmap-的长度为什么是-2-的幂次方" tabindex="-1"><a class="header-anchor" href="#_27-hashmap-的长度为什么是-2-的幂次方" aria-hidden="true">#</a> 27.HashMap 的长度为什么是 2 的幂次方</h2><p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。数组下标的计算方法是“ <code>(n - 1) &amp; hash</code>”。（hash%length==hash&amp;(length-1)）</p><h2 id="_28-hashmap-多线程操作导致死循环问题" tabindex="-1"><a class="header-anchor" href="#_28-hashmap-多线程操作导致死循环问题" aria-hidden="true">#</a> 28.HashMap 多线程操作导致死循环问题</h2><h2 id="_29-hashmap-有哪几种常见的遍历方式" tabindex="-1"><a class="header-anchor" href="#_29-hashmap-有哪几种常见的遍历方式" aria-hidden="true">#</a> 29.HashMap 有哪几种常见的遍历方式?</h2><h2 id="_30-concurrenthashmap-和-hashtable-的区别" tabindex="-1"><a class="header-anchor" href="#_30-concurrenthashmap-和-hashtable-的区别" aria-hidden="true">#</a> 30.ConcurrentHashMap 和 Hashtable 的区别</h2><p><code>ConcurrentHashMap</code> 和 <code>Hashtable</code> 的区别主要体现在实现线程安全的方式上不同：</p><ul><li><code>ConcurrentHashMap</code>并发控制使用 synchronized 和 CAS 来操作。</li><li><code>Hashtable</code> :使用 synchronized 来保证线程安全，效率非常低下。</li></ul><h2 id="_31-collections-工具类常用方法" tabindex="-1"><a class="header-anchor" href="#_31-collections-工具类常用方法" aria-hidden="true">#</a> 31.Collections 工具类常用方法</h2><ul><li>排序。</li><li>查找,替换操作。</li><li>同步控制(不推荐，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合)。</li></ul><h1 id="三、并发编程" tabindex="-1"><a class="header-anchor" href="#三、并发编程" aria-hidden="true">#</a> 三、并发编程</h1><h2 id="_32-请简要描述线程与进程的关系-区别及优缺点" tabindex="-1"><a class="header-anchor" href="#_32-请简要描述线程与进程的关系-区别及优缺点" aria-hidden="true">#</a> 32.请简要描述线程与进程的关系,区别及优缺点？</h2><ul><li>一个进程中可以有多个线程，多个线程共享进程的堆和方法区 (JDK1.8 之后的元空间)资源，但是每个线程有自己的程序计数器、虚拟机栈 和 本地方法栈。 <ul><li>程序计数器私有主要是为了线程切换后能恢复到正确的执行位置。</li><li>为了<strong>保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是线程私有的。</li></ul></li><li>堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (几乎所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</li></ul><h2 id="_33-为什么要使用多线程呢" tabindex="-1"><a class="header-anchor" href="#_33-为什么要使用多线程呢" aria-hidden="true">#</a> 33.为什么要使用多线程呢?</h2><p>利用好多线程机制可以大大提高系统整体的并发能力以及性能。</p><h2 id="_34-使用多线程可能带来什么问题" tabindex="-1"><a class="header-anchor" href="#_34-使用多线程可能带来什么问题" aria-hidden="true">#</a> 34.使用多线程可能带来什么问题?</h2><p>并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：内存泄漏、死锁、线程不安全等等。</p><h2 id="_35-说说线程的生命周期和状态" tabindex="-1"><a class="header-anchor" href="#_35-说说线程的生命周期和状态" aria-hidden="true">#</a> 35.说说线程的生命周期和状态?</h2><ul><li>线程创建之后它将处于 NEW（新建） 状态，调用 start() 方法后开始运行，线程这时候处于 READY（可运行） 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 RUNNING（运行） 状态。</li><li>当线程执行 wait()方法之后，线程进入 WAITING（等待） 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 TIMED_WAITING(超时等待) 状态相当于在等待状态的基础上增加了超时限制。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。</li><li>当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 BLOCKED（阻塞） 状态。线程在执行 Runnable 的run()方法之后将会进入到 TERMINATED（终止） 状态。</li></ul><h2 id="_36-什么是上下文切换" tabindex="-1"><a class="header-anchor" href="#_36-什么是上下文切换" aria-hidden="true">#</a> 36.什么是上下文切换?</h2><ul><li>线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 上下文切换。</li><li>上下文切换是现代操作系统的基本功能，因其每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，如果频繁切换就会造成整体效率低下。</li></ul><h2 id="_37-什么是线程死锁-如何避免死锁" tabindex="-1"><a class="header-anchor" href="#_37-什么是线程死锁-如何避免死锁" aria-hidden="true">#</a> 37.什么是线程死锁?如何避免死锁?</h2><ul><li>线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。</li><li>破坏死锁的产生的必要条件即可： <ul><li>破坏请求与保持条件 ：一次性申请所有的资源。</li><li>破坏不剥夺条件 ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li><li>破坏循环等待条件 ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li></ul></li></ul><h2 id="_38-说说-sleep-方法和-wait-方法区别和共同点" tabindex="-1"><a class="header-anchor" href="#_38-说说-sleep-方法和-wait-方法区别和共同点" aria-hidden="true">#</a> 38.说说 sleep() 方法和 wait() 方法区别和共同点?</h2><ul><li>两者最主要的区别在于：<strong><code>sleep()</code> 方法没有释放锁，而 <code>wait()</code> 方法释放了锁</strong> 。</li><li>两者都可以暂停线程的执行。</li><li><code>wait()</code> 通常被用于线程间交互/通信，<code>sleep() </code>通常被用于暂停执行。</li><li><code>wait()</code> 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <code>notify() </code>或者 <code>notifyAll()</code> 方法。<code>sleep() </code>方法执行完成后，线程会自动苏醒。或者可以使用 <code>wait(long timeout)</code> 超时后线程会自动苏醒。</li></ul><h2 id="_39-为什么我们调用-start-方法时会执行-run-方法-为什么我们不能直接调用-run-方法" tabindex="-1"><a class="header-anchor" href="#_39-为什么我们调用-start-方法时会执行-run-方法-为什么我们不能直接调用-run-方法" aria-hidden="true">#</a> 39.为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</h2><p>new 一个 Thread，线程进入了新建状态。调用 <code>start()</code>方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 <code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。 但是，直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p><h2 id="_40-说一说自己对于-synchronized-关键字的了解" tabindex="-1"><a class="header-anchor" href="#_40-说一说自己对于-synchronized-关键字的了解" aria-hidden="true">#</a> 40.说一说自己对于 synchronized 关键字的了解</h2><p>synchronized 关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</p><h2 id="_41-说说自己是怎么使用-synchronized-关键字" tabindex="-1"><a class="header-anchor" href="#_41-说说自己是怎么使用-synchronized-关键字" aria-hidden="true">#</a> 41.说说自己是怎么使用 synchronized 关键字</h2><ul><li>修饰实例方法: 作用于当前对象实例加锁，进入同步代码前要获得 当前对象实例的锁。</li><li>修饰静态方法: 也就是给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 当前 class 的锁。</li><li>修饰代码块 ：指定加锁对象，对给定对象/类加锁。synchronized(this|object) 表示进入同步代码库前要获得给定对象的锁。</li></ul><h2 id="_42-构造方法可以使用-synchronized-关键字修饰么" tabindex="-1"><a class="header-anchor" href="#_42-构造方法可以使用-synchronized-关键字修饰么" aria-hidden="true">#</a> 42.构造方法可以使用 synchronized 关键字修饰么？</h2><ul><li><p>构造方法不能使用 synchronized 关键字修饰。</p></li><li><p>构造方法本身就属于线程安全的，不存在同步的构造方法一说。</p></li></ul><h2 id="_43-讲一下-synchronized-关键字的底层原理" tabindex="-1"><a class="header-anchor" href="#_43-讲一下-synchronized-关键字的底层原理" aria-hidden="true">#</a> 43.讲一下 synchronized 关键字的底层原理</h2><h2 id="_44-说说-jdk1-6-之后的-synchronized-关键字底层做了哪些优化-可以详细介绍一下这些优化吗" tabindex="-1"><a class="header-anchor" href="#_44-说说-jdk1-6-之后的-synchronized-关键字底层做了哪些优化-可以详细介绍一下这些优化吗" aria-hidden="true">#</a> 44.说说 JDK1.6 之后的 synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗</h2><ul><li>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。</li><li>锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</li></ul><h2 id="_45-谈谈-synchronized-和-reentrantlock-的区别" tabindex="-1"><a class="header-anchor" href="#_45-谈谈-synchronized-和-reentrantlock-的区别" aria-hidden="true">#</a> 45.谈谈 synchronized 和 ReentrantLock 的区别</h2><ul><li>两者都是可重入锁。 <ul><li>自己可以再次获取自己的内部锁。</li><li>同一个线程每次获取锁，锁的计数器都自增 1，所以要等到锁的计数器下降为 0 时才能释放锁。</li></ul></li><li>synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API。</li><li>ReentrantLock 比 synchronized 增加了一些高级功能： <ul><li>等待可中断 : ReentrantLock提供了一种能够中断等待锁的线程的机制，通过 lock.lockInterruptibly() 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li><li>可实现公平锁 : ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。</li><li>实现选择性通知（锁可以绑定多个条件）。</li></ul></li></ul><h2 id="_46-cpu-缓存模型" tabindex="-1"><a class="header-anchor" href="#_46-cpu-缓存模型" aria-hidden="true">#</a> 46.CPU 缓存模型</h2><ul><li>CPU 缓存则是为了解决 CPU 处理速度和内存处理速度不对等的问题。</li><li>CPU Cache 缓存的是内存数据用于解决 CPU 处理速度和内存不匹配的问题，内存缓存的是硬盘数据用于解决硬盘访问速度过慢的问题。</li><li>CPU 为了解决内存缓存不一致性问题可以通过制定缓存一致协议或者其他手段来解决。</li></ul><h2 id="_47-讲一下-jmm-java-内存模型" tabindex="-1"><a class="header-anchor" href="#_47-讲一下-jmm-java-内存模型" aria-hidden="true">#</a> 47.讲一下 JMM(Java 内存模型)</h2><ul><li>Java 内存模型主要目的是为了屏蔽系统和硬件的差异，避免一套代码在不同的平台下产生的效果不一致。</li><li>主内存 ：所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量还是方法中的本地变量(也称局部变量)</li><li>本地内存 ：每个线程都有一个私有的本地内存来存储共享变量的副本，并且，每个线程只能访问自己的本地内存，无法访问其他线程的本地内存。本地内存是 JMM 抽象出来的一个概念，存储了主内存中的共享变量副本。</li><li>数据的不一致：要解决这个问题，就需要把变量声明为 volatile ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。volatile 关键字 除了防止 JVM 的指令重排 ，还有一个重要的作用就是保证变量的可见性。</li></ul><h2 id="_48-并发编程的三个重要特性" tabindex="-1"><a class="header-anchor" href="#_48-并发编程的三个重要特性" aria-hidden="true">#</a> 48.并发编程的三个重要特性</h2><ol><li><strong>可见性</strong> ：当一个线程对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。<code>volatile</code> 关键字可以保证共享变量的可见性。</li><li><strong>有序性</strong> ：代码在执行的过程中的先后顺序，Java 在编译器以及运行期间的优化，代码的执行顺序未必就是编写代码时候的顺序。<code>volatile</code> 关键字可以禁止指令进行重排序优化。</li><li><strong>原子性</strong> : 一次操作或者多次操作，要么所有的操作全部都得到执行并且不会受到任何因素的干扰而中断，要么都不执行。<code>synchronized</code> 可以保证代码片段的原子性。</li></ol><h2 id="_49-说说-synchronized-关键字和-volatile-关键字的区别" tabindex="-1"><a class="header-anchor" href="#_49-说说-synchronized-关键字和-volatile-关键字的区别" aria-hidden="true">#</a> 49.说说 synchronized 关键字和 volatile 关键字的区别</h2><p>synchronized 关键字和 volatile 关键字是两个互补的存在，而不是对立的存在！</p><ul><li>volatile 关键字是线程同步的轻量级实现，所以 volatile 性能肯定比synchronized关键字要好 。但是 volatile 关键字只能用于变量而 synchronized 关键字可以修饰方法以及代码块 。</li><li>volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。</li><li>volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized 关键字解决的是多个线程之间访问资源的同步性。</li></ul><h2 id="_50-threadlocal" tabindex="-1"><a class="header-anchor" href="#_50-threadlocal" aria-hidden="true">#</a> 50.ThreadLocal</h2><ul><li>如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的本地副本，不会刷回到主存，从而避免了线程安全问题。</li><li>ThreadLocal 原理：</li><li>ThreadLocal 内存泄露问题： <ul><li>ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用,而 value 是强引用。所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。</li><li>这样一来，ThreadLocalMap 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。</li><li>ThreadLocalMap 实现中已经考虑了这种情况，在调用 set()、get()、remove() 方法的时候，会清理掉 key 为 null 的记录。使用完 ThreadLocal方法后 最好手动调用remove()方法。</li></ul></li></ul><h2 id="_51-为什么要用线程池" tabindex="-1"><a class="header-anchor" href="#_51-为什么要用线程池" aria-hidden="true">#</a> 51.为什么要用线程池？</h2><ul><li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><h2 id="_52-实现-runnable-接口和-callable-接口的区别" tabindex="-1"><a class="header-anchor" href="#_52-实现-runnable-接口和-callable-接口的区别" aria-hidden="true">#</a> 52.实现 Runnable 接口和 Callable 接口的区别</h2><ul><li><code>Runnable</code> 接口 不会返回结果或抛出检查异常，但是 <code>Callable</code> 接口 可以。</li><li>所以，如果任务不需要返回结果或抛出异常推荐使用 <code>Runnable</code> 接口 ，这样代码看起来会更加简洁。</li></ul><h2 id="_53-执行-execute-方法和-submit-方法的区别是什么呢" tabindex="-1"><a class="header-anchor" href="#_53-执行-execute-方法和-submit-方法的区别是什么呢" aria-hidden="true">#</a> 53.执行 execute()方法和 submit()方法的区别是什么呢？</h2><ul><li><code>execute()</code>方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否。</li><li><code>submit()</code>方法用于提交需要返回值的任务。线程池会返回一个 <code>Future</code> 类型的对象，通过这个 <code>Future</code> 对象可以判断任务是否执行成功，并且可以通过 <code>Future</code> 的 <code>get()</code>方法来获取返回值，<code>get()</code>方法会阻塞当前线程直到任务完成，而使用 <code>get(long timeout，TimeUnit unit)</code>方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</li></ul><h2 id="_54-如何创建线程池" tabindex="-1"><a class="header-anchor" href="#_54-如何创建线程池" aria-hidden="true">#</a> 54.如何创建线程池</h2><p>通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p><h2 id="_55-线程池的七个参数" tabindex="-1"><a class="header-anchor" href="#_55-线程池的七个参数" aria-hidden="true">#</a> 55.线程池的七个参数</h2><blockquote><p>ThreadPoolExecutor</p></blockquote><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">ThreadPoolExecutor</span>
    <span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>
     <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>
     <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>
     <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span>
     <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> workQueue<span class="token punctuation">,</span>
     <span class="token class-name">ThreadFactory</span> threadFactory<span class="token punctuation">,</span>
     <span class="token class-name">RejectedExecutionHandler</span> handler<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><table><thead><tr><th>corePoolSize</th><th>指定了线程池里的线程数量，核心线程池大小</th></tr></thead><tbody><tr><td>maximumPoolSize</td><td>指定了线程池里的最大线程数量</td></tr><tr><td>keepAliveTime</td><td>当线程池线程数量大于corePoolSize时候，多出来的空闲线程，多长时间会被销毁</td></tr><tr><td>unit</td><td>时间单位，TimeUnit</td></tr><tr><td>workQueue</td><td>任务队列，用于存放提交但是尚未被执行的任务</td></tr><tr><td>threadFactory</td><td>线程工厂，用于创建线程，线程工厂就是给我们new线程的</td></tr><tr><td>handler</td><td>所谓拒绝策略，是指将任务添加到线程池中时，线程池拒绝该任务所采取的相应策略</td></tr></tbody></table><h2 id="_56-cas和aqs" tabindex="-1"><a class="header-anchor" href="#_56-cas和aqs" aria-hidden="true">#</a> 56.CAS和AQS</h2><ul><li>CAS：是给一个元素赋值的时候，先看看内存里的那个值到底变没变，如果没变我就修改，变了我就不改了，其实这是一种无锁操作，不需要挂起线程，无锁的思路就是先尝试，如果失败了，进行补偿，也就是你可以继续尝试。这样在少量竞争的情况下能很大程度提升性能。</li><li>抽象队列同步器，用来解决线程同步执行的问题。</li></ul><h2 id="_57-用过-countdownlatch-么-什么场景下用的" tabindex="-1"><a class="header-anchor" href="#_57-用过-countdownlatch-么-什么场景下用的" aria-hidden="true">#</a> 57.用过 CountDownLatch 么？什么场景下用的？</h2><ul><li>这个类常常用于等待，等多个线程执行完毕，再让某个线程执行。</li><li>CountDownLatch的典型用法就是：某一线程在开始运行前等待n个线程执行完毕。</li><li>CountDownLatch是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当CountDownLatch使用完毕后，它不能再次被使用。</li><li>CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。</li></ul><h1 id="四、jvm" tabindex="-1"><a class="header-anchor" href="#四、jvm" aria-hidden="true">#</a> 四、JVM</h1><h2 id="_58-介绍下-java-内存区域-运行时数据区" tabindex="-1"><a class="header-anchor" href="#_58-介绍下-java-内存区域-运行时数据区" aria-hidden="true">#</a> 58.介绍下 Java 内存区域（运行时数据区）</h2><ul><li><p>线程私有的：</p><ul><li><p>程序计数器</p></li><li><p>虚拟机栈</p></li><li><p>本地方法栈</p></li></ul></li><li><p>线程共享的：</p><ul><li><p>堆</p></li><li><p>方法区</p></li><li><p>直接内存 (非运行时数据区的一部分)</p></li></ul></li></ul><blockquote><p>程序计数器</p></blockquote><ul><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li><li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li></ul><blockquote><p>虚拟机栈</p></blockquote><ul><li>Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。</li><li>局部变量表主要存放了编译期可知的各种数据类型、对象引用。</li><li>那么方法/函数如何调用？ <ul><li>Java 栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入 Java 栈，每一个函数调用结束后，都会有一个栈帧被弹出。</li><li>Java 方法有两种返回方式：return 语句。抛出异常。不管哪种返回方式都会导致栈帧被弹出。</li></ul></li></ul><blockquote><p>本地方法栈</p></blockquote><p>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</p><blockquote><p>堆</p></blockquote><ul><li>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</li><li>Java 堆是垃圾收集器管理的主要区域，因此也被称作GC 堆（Garbage Collected Heap）。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代；再细致一点有：Eden、Survivor、Old 等空间。</li></ul><blockquote><p>方法区</p></blockquote><p>方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><blockquote><p>运行时常量池</p></blockquote><ul><li>运行时常量池是方法区的一部分。</li><li>Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池表（用于存放编译期生成的各种字面量和符号引用）。</li></ul><h2 id="_59-对象的创建" tabindex="-1"><a class="header-anchor" href="#_59-对象的创建" aria-hidden="true">#</a> 59.对象的创建</h2><ul><li><strong>类加载检查</strong>：虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</li><li><strong>分配内存</strong>：在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。分配方式有 “指针碰撞” 和 “空闲列表” 两种，选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</li><li><strong>初始化零值</strong>：内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</li><li><strong>设置对象头</strong>：初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</li><li><strong>执行 init 方法</strong>：在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，&lt;init&gt; 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 &lt;init&gt; 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</li></ul><h2 id="_60-字符串常量池常见问题" tabindex="-1"><a class="header-anchor" href="#_60-字符串常量池常见问题" aria-hidden="true">#</a> 60.字符串常量池常见问题</h2><blockquote><p>String 类型的变量和常量做“+”运算时发生了什么？</p></blockquote><ul><li>对于编译期可以确定值的字符串，也就是常量字符串 ，jvm 会将其存入字符串常量池。并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化。</li><li>引用的值在程序编译期是无法确定的，编译器无法对其进行优化。</li><li>对象引用和“+”的字符串拼接方式，实际上是通过 StringBuilder 调用 append() 方法实现的，拼接完成之后调用 toString() 得到一个 String 对象 。</li><li>字符串使用 final 关键字声明之后，可以让编译器当做常量来处理。</li></ul><h2 id="_61-类加载过程" tabindex="-1"><a class="header-anchor" href="#_61-类加载过程" aria-hidden="true">#</a> 61.类加载过程</h2><p>Class 文件需要加载到虚拟机中之后才能运行和使用，那么虚拟机是如何加载这些 Class 文件呢？</p><p>系统加载 Class 类型的文件主要三步：加载-&gt;连接-&gt;初始化。连接过程又可分为三步：验证-&gt;准备-&gt;解析。</p><h1 id="五、数据库" tabindex="-1"><a class="header-anchor" href="#五、数据库" aria-hidden="true">#</a> 五、数据库</h1><h2 id="mysql" tabindex="-1"><a class="header-anchor" href="#mysql" aria-hidden="true">#</a> MySQL</h2><h2 id="_62-锁机制与-innodb-锁算法" tabindex="-1"><a class="header-anchor" href="#_62-锁机制与-innodb-锁算法" aria-hidden="true">#</a> 62.锁机制与 InnoDB 锁算法</h2><blockquote><p>表级锁和行级锁对比：</p></blockquote><ul><li>表级锁： MySQL 中锁定 粒度最大 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM 和 InnoDB 引擎都支持表级锁。</li><li>行级锁： MySQL 中锁定 粒度最小 的一种锁，只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。</li></ul><blockquote><p>InnoDB 存储引擎的锁的算法有三种：</p></blockquote><ul><li>Record lock：记录锁，单个行记录上的锁</li><li>Gap lock：间隙锁，锁定一个范围，不包括记录本身</li><li>Next-key lock：record+gap 临键锁，锁定一个范围，包含记录本身。</li></ul><h2 id="_63-查询缓存" tabindex="-1"><a class="header-anchor" href="#_63-查询缓存" aria-hidden="true">#</a> 63.查询缓存</h2><p>执行查询语句的时候，会先查询缓存。不过，MySQL 8.0 版本后移除，因为这个功能不太实用。</p><h2 id="_64-何为事务" tabindex="-1"><a class="header-anchor" href="#_64-何为事务" aria-hidden="true">#</a> 64.何为事务？</h2><ul><li>事务是逻辑上的一组操作，要么都执行，要么都不执行。</li><li>事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账 1000 元，这个转账会涉及到两个关键操作就是：将小明的余额减少 1000 元；将小红的余额增加 1000 元。事务会把这两个操作就可以看成逻辑上的一个整体，这个整体包含的操作要么都成功，要么都要失败。这样就不会出现小明余额减少而小红的余额却并没有增加的情况。</li></ul><h2 id="_65-何为数据库事务" tabindex="-1"><a class="header-anchor" href="#_65-何为数据库事务" aria-hidden="true">#</a> 65.何为数据库事务？</h2><p>数据库事务可以保证多个对数据库的操作（也就是 SQL 语句）构成一个逻辑上的整体。构成这个逻辑上的整体的这些数据库操作遵循：要么全部执行成功,要么全部不执行 。</p><h2 id="_66-何为-acid-特性呢" tabindex="-1"><a class="header-anchor" href="#_66-何为-acid-特性呢" aria-hidden="true">#</a> 66.何为 ACID 特性呢？</h2><ul><li>原子性（Atomicity） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用。</li><li>一致性（Consistency）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的。</li><li>隔离性（Isolation）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的。</li><li>持久性（Durability）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li></ul><h2 id="_67-数据事务的实现原理呢" tabindex="-1"><a class="header-anchor" href="#_67-数据事务的实现原理呢" aria-hidden="true">#</a> 67.数据事务的实现原理呢？</h2><ul><li>MySQL InnoDB 引擎使用 redo log(重做日志) 保证事务的持久性，使用 undo log(回滚日志) 来保证事务的原子性。</li><li>MySQL InnoDB 引擎通过 锁机制、MVCC 等手段来保证事务的隔离性（ 默认支持的隔离级别是 REPEATABLE-READ ）。</li><li>保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。</li></ul><h2 id="_68-并发事务带来哪些问题" tabindex="-1"><a class="header-anchor" href="#_68-并发事务带来哪些问题" aria-hidden="true">#</a> 68.并发事务带来哪些问题?</h2><ul><li>脏读（Dirty read）: 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</li><li>丢失修改（Lost to modify）: 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失。</li><li>不可重复读（Unrepeatable read）: 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</li><li>幻读（Phantom read）: 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li></ul><h2 id="_69-事务隔离级别有哪些" tabindex="-1"><a class="header-anchor" href="#_69-事务隔离级别有哪些" aria-hidden="true">#</a> 69.事务隔离级别有哪些?</h2><ul><li>EAD-UNCOMMITTED(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li><li>READ-COMMITTED(读取已提交)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li><li>REPEATABLE-READ(可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li><li>SERIALIZABLE(可串行化)： 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li></ul><h2 id="_70-mysql-的默认隔离级别是什么" tabindex="-1"><a class="header-anchor" href="#_70-mysql-的默认隔离级别是什么" aria-hidden="true">#</a> 70.MySQL 的默认隔离级别是什么?</h2><ul><li>MySQL InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读）。我们可以通过SELECT @@tx_isolation;命令来查看，MySQL 8.0 该命令改为SELECT @@transaction_isolation。</li><li>MySQL InnoDB 的 REPEATABLE-READ（可重读）并不保证避免幻读，需要应用使用加锁读来保证。而这个加锁读使用到的机制就是 Next-Key Locks。</li></ul><h2 id="_71-mysql-索引详解" tabindex="-1"><a class="header-anchor" href="#_71-mysql-索引详解" aria-hidden="true">#</a> 71.MySQL 索引详解</h2><h3 id="何为索引-有什么作用" tabindex="-1"><a class="header-anchor" href="#何为索引-有什么作用" aria-hidden="true">#</a> 何为索引？有什么作用？</h3><ul><li>索引是一种用于快速查询和检索数据的数据结构。常见的索引结构有: B 树， B+树和 Hash。</li><li>索引的作用就相当于目录的作用。打个比方: 我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了。</li></ul><h3 id="索引的优缺点" tabindex="-1"><a class="header-anchor" href="#索引的优缺点" aria-hidden="true">#</a> 索引的优缺点</h3><p>优点 ：</p><ul><li>使用索引可以大大加快 数据的检索速度（大大减少检索的数据量）, 这也是创建索引的最主要的原因。</li><li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li></ul><p>缺点 ：</p><ul><li>创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。</li><li>索引需要使用物理文件存储，也会耗费一定空间。</li></ul><p>但是，<strong>使用索引一定能提高查询性能吗?</strong></p><p>大多数情况下，索引查询都是比全表扫描要快的。但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升。</p><h3 id="索引的底层数据结构" tabindex="-1"><a class="header-anchor" href="#索引的底层数据结构" aria-hidden="true">#</a> 索引的底层数据结构</h3><blockquote><p>Hash表 &amp; B+树</p></blockquote><ul><li>哈希表是键值对的集合，通过键(key)即可快速取出对应的值(value)，因此哈希表可以快速检索数据（接近 O（1））。</li><li>为何能够通过 key 快速取出 value呢？ 原因在于 哈希算法（也叫散列算法）。通过哈希算法，我们可以快速找到 key 对应的 index，找到了 index 也就找到了对应的 value。</li><li>但是！哈希算法有个 Hash 冲突 问题，也就是说多个不同的 key 最后得到的 index 相同。通常情况下，我们常用的解决办法是 链地址法。链地址法就是将哈希冲突数据存放在链表中。就比如 JDK1.8 之前 HashMap 就是通过链地址法来解决哈希冲突的。不过，JDK1.8 以后HashMap为了减少链表过长的时候搜索时间过长引入了红黑树。</li></ul><blockquote><p>既然哈希表这么快，为什么MySQL 没有使用其作为索引的数据结构呢？</p></blockquote><ul><li>Hash 冲突问题 ：我们上面也提到过Hash 冲突了，不过对于数据库来说这还不算最大的缺点。</li><li>Hash 索引不支持顺序和范围查询(Hash 索引不支持顺序和范围查询是它最大的缺点： 假如我们要对表中的数据进行排序或者进行范围查询，那 Hash 索引可就不行了。</li></ul><blockquote><p>B 树&amp; B+树</p></blockquote><ul><li>B 树也称 B-树,全称为 多路平衡查找树 ，B+ 树是 B 树的一种变体。B 树和 B+树中的 B 是 Balanced （平衡）的意思。目前大部分数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构。</li></ul><blockquote><p>B 树&amp; B+树两者有何异同呢？</p></blockquote><ul><li>B 树的所有节点既存放键(key) 也存放 数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。</li><li>B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</li><li>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</li></ul><h3 id="索引类型" tabindex="-1"><a class="header-anchor" href="#索引类型" aria-hidden="true">#</a> 索引类型</h3><blockquote><p>聚簇索引和非聚簇索引</p></blockquote><ul><li>【主键和数据】共存的索引被称之为【聚簇索引】，其他的，比如我们使用【姓名列+主键】建立的索引，可以称为【非聚簇索引】，或者【辅助索引】，或者【二级索引】，同时聚簇索引只有在innodb引擎中才存在，而在myIsam中是不存在的。</li></ul><blockquote><p>二级索引</p></blockquote><ul><li><strong>普通索引</strong> （常规索引）(normal)：就是普普通通的索引，没有什么特殊要求，理论上任何列都可以当做普通索引，有的列【数据量比较大】，使用前几个字符就能【很快标识】出来一行数据，那我们就可以使用这种方式建立索引，比如我们的邮箱，邮箱很多后缀是相同的我们完全可以忽略。</li><li><strong>唯一索引</strong>（UNIQUE ）：对列的要求：索引列的值不能重复。</li><li><strong>复合索引</strong>（联合索引）：当【查询语句】中包含【多个查询条件，且查询的顺序基本保持一致】时，我们推荐使用复合索引，索引的【组合使用】效率是低于【复合索引】的。</li><li><strong>全文索引</strong>（FULLTEXT）：做全文检索（不如百度的搜索功能）使用的索引，但是这种场景，我们有更好的替代品，如：ElacticSearch，所以实际使用不多，只当了解。</li><li><strong>hash索引</strong>：hash索引是Memory存储引擎的默认方式，而且只有memory引擎支持hash索引，memory的数据是放在内存中的，一旦服务关闭，表中的数据就会丢失。</li><li><strong>空间索引</strong>（SPATIAL）：MySQL在5.7之后的版本支持了空间索引，而且支持OpenGIS几何数据模型。这是在地理位置领域使用的一种索引，其他场景用的很少，所以不需要深入学习。</li><li><strong>覆盖索引</strong>：覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了， 而无需回表查询。</li></ul><h3 id="explain的用法" tabindex="-1"><a class="header-anchor" href="#explain的用法" aria-hidden="true">#</a> explain的用法</h3><p>explain关键字可以模拟MySQL优化器执行SQL语句，可以很好的分析SQL语句或表结构的性能瓶颈。explain的使用很简单，只需要在目标sql前加上这个关键字就可以了。</p><p>执行explain会产生以下11列内容，如下：</p><table><thead><tr><th>列号</th><th>列</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>id</td><td>select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序</td></tr><tr><td>2</td><td>select_type</td><td>查询类型</td></tr><tr><td>3</td><td>table</td><td>正在访问哪个表</td></tr><tr><td>4</td><td>partitions</td><td>匹配的分区</td></tr><tr><td>5</td><td>type</td><td>/访问的类型</td></tr><tr><td>6</td><td>possible_keys</td><td>显示可能应用在这张表中的索引，一个或多个，但不一定实际使用到</td></tr><tr><td>7</td><td>key</td><td>实际使用到的索引，如果为NULL，则没有使用索引</td></tr><tr><td>8</td><td>key_len</td><td>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度</td></tr><tr><td>9</td><td>ref</td><td>显示索引的哪一列被使用了，如果可能的话，是一个常数，哪些列或常量被用于查找索引列上的值</td></tr><tr><td>10</td><td>rows</td><td>根据表统计信息及索引选用情况，大致估算出找到所需的记录所需读取的行数 filtered //查询的表行占表的百分比</td></tr><tr><td>11</td><td>filtered</td><td>查询的表行占表的百分比</td></tr><tr><td>12</td><td>Extra</td><td>包含不适合在其它列中显示但十分重要的额外信息</td></tr></tbody></table><p>重点是type字段，最好到最差：掌握以下10种常见的即可NULL&gt;system&gt;const&gt;eq_ref&gt;ref&gt;ref_or_null&gt;index_merge&gt;range&gt;index&gt;ALL</p><h3 id="使用索引的问题" tabindex="-1"><a class="header-anchor" href="#使用索引的问题" aria-hidden="true">#</a> 使用索引的问题</h3><ul><li><p>哪些情况下适合建索引</p><ul><li><p>频繁作为where条件语句查询的字段。</p></li><li><p>关联字段需要建立索引。</p></li><li><p>分组，排序字段可以建立索引。</p></li><li><p>统计字段可以建立索引，例如count()，max()等。</p></li></ul></li><li><p>哪些情况下不适合建索引</p><ul><li><p>频繁更新的字段不适合建立索引。</p></li><li><p>where条件中用不到的字段不适合建立索引。</p></li><li><p>表数据可以确定比较少的不需要建索引。</p></li><li><p>数据重复且发布比较均匀的的字段不适合建索引（唯一性太差的字段不适合建立索引），例如性别，真假值。</p></li><li><p>参与列计算的列不适合建索引，索引会失效。</p></li></ul></li><li><p>能用复合索引的要使用复合索引。</p></li><li><p>null值也是可以走索引的，他被处理成最小值放在b+树的最左侧。</p></li><li><p>使用短索引：对字符串的列创建索引，如果可能，应该指定一个前缀长度。例如，如果有一个CHAR(255)的 列，如果在前10 个或20 个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。</p></li><li><p>排序的索引问题：</p><ul><li>mysql查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。</li><li>因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要，最好给这些列创建复合索引。</li></ul></li><li><p>MySQL索引失效的几种情况：</p><ul><li>如果条件中有or，即使其中有条件带索引也不会使用走索引，除非全部条件都有索引。</li><li>复合索引不满足最左原则就不能使用全部索引。</li><li>like查询以%开头。</li><li>存在列计算。</li><li>如果mysql估计使用全表扫描要比使用索引快，则不使用索引，比如结果的量很大。</li><li>存在类型转化。</li></ul></li></ul><h2 id="redis" tabindex="-1"><a class="header-anchor" href="#redis" aria-hidden="true">#</a> Redis</h2><h2 id="_72-什么是-redis" tabindex="-1"><a class="header-anchor" href="#_72-什么是-redis" aria-hidden="true">#</a> 72.什么是 Redis？</h2><p>Redis是一个基于 C 语言开发的开源数据库（BSD 许可），与传统数据库不同的是 Redis 的数据是存在内存中的（内存数据库），读写速度非常快，被广泛应用于缓存方向。并且，Redis 存储的是 KV 键值对数据。</p><h2 id="_73-redis-为什么这么快" tabindex="-1"><a class="header-anchor" href="#_73-redis-为什么这么快" aria-hidden="true">#</a> 73.Redis 为什么这么快？</h2><p>Redis 内部做了非常多的性能优化，比较重要的主要有下面 3 点：</p><ul><li>Redis 基于内存，内存的访问速度是磁盘的上千倍；</li><li>Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型，主要是单线程事件循环和 IO 多路复用（Redis 线程模式后面会详细介绍到）；</li><li>Redis 内置了多种优化过后的数据结构实现，性能非常高。</li></ul><h2 id="_74-redis-除了做缓存-还能做什么" tabindex="-1"><a class="header-anchor" href="#_74-redis-除了做缓存-还能做什么" aria-hidden="true">#</a> 74.Redis 除了做缓存，还能做什么？</h2><ul><li>分布式锁 ： 通过 Redis 来做分布式锁是一种比较常见的方式。通常情况下，我们都是基于 Redisson 来实现分布式锁。</li><li>一般是通过 Redis + Lua 脚本的方式来实现限流。</li><li>Redis 自带的 list 数据结构可以作为一个简单的队列使用。Redis 5.0 中增加的 Stream 类型的数据结构更加适合用来做消息队列。它比较类似于 Kafka，有主题和消费组的概念，支持消息持久化以及 ACK 机制。</li><li>通过 Redis 以及 Redis 扩展（比如 Redisson）提供的数据结构，我们可以很方便地完成很多复杂的业务场景比如通过 bitmap 统计活跃用户、通过 sorted set 维护排行榜。</li></ul><h2 id="_75-redis-数据结构" tabindex="-1"><a class="header-anchor" href="#_75-redis-数据结构" aria-hidden="true">#</a> 75.Redis 数据结构</h2><blockquote><p>Redis 常用的数据结构有哪些？</p></blockquote><ul><li><p>5 种基础数据结构 ：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。</p></li><li><p>3 种特殊数据结构 ：HyperLogLogs（基数统计）、Bitmap （位存储）、Geospatial (地理位置)。</p></li></ul><blockquote><p>String 的应用场景有哪些？</p></blockquote><ul><li>常规数据（比如 session、token、、序列化后的对象）的缓存。</li><li>计数比如用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数。</li><li>分布式锁(利用 SETNX key value 命令可以实现一个最简易的分布式锁)。</li></ul><blockquote><p>String 还是 Hash 存储对象数据更好呢？</p></blockquote><ul><li>String 存储的是序列化后的对象数据，存放的是整个对象。Hash 是对对象的每个字段单独存储，可以获取部分字段的信息，也可以修改或者添加部分字段，节省网络流量。如果对象中某些字段需要经常变动或者经常需要单独查询对象中的个别字段信息，Hash 就非常适合。</li><li>String 存储相对来说更加节省内存，缓存相同数量的对象数据，String 消耗的内存约是 Hash 的一半。并且，存储具有多层嵌套的对象时也方便很多。如果系统对性能和资源消耗非常敏感的话，String 就非常适合。</li><li>在绝大部分情况，我们建议使用 String 来存储对象数据即可！</li></ul><blockquote><p>购物车信息用 String 还是 Hash 存储更好呢?</p></blockquote><p>由于购物车中的商品频繁修改和变动，购物车信息建议使用 Hash 存储：</p><ul><li>用户 id 为 key</li><li>商品 id 为 field，商品数量为 value。</li></ul><p>那用户购物车信息的维护具体应该怎么操作呢？</p><ul><li>用户添加商品就是往 Hash 里面增加新的 field 与 value；</li><li>查询购物车信息就是遍历对应的 Hash；</li><li>更改商品数量直接修改对应的 value 值（直接 set 或者做运算皆可）；</li><li>删除商品就是删除 Hash 中对应的 field；</li><li>清空购物车直接删除对应的 key 即可。</li></ul><blockquote><p>使用 Redis 实现一个排行榜怎么做？</p></blockquote><ul><li>Redis 中有一个叫做 <code>sorted set</code> 的数据结构经常被用在各种排行榜的场景，比如直播间送礼物的排行榜、朋友圈的微信步数排行榜、王者荣耀中的段位排行榜、话题热度排行榜等等。</li><li>相关的一些 Redis 命令: <code>ZRANGE</code> (从小到大排序) 、 <code>ZREVRANGE</code> （从大到小排序）、<code>ZREVRANK</code> (指定元素排名)。</li></ul><blockquote><p>使用 Set 实现抽奖系统需要用到什么命令？</p></blockquote><p><code>SPOP key count</code> ： 随机移除并获取指定集合中一个或多个元素，适合不允许重复中奖的场景。</p><p><code>SRANDMEMBER key count</code> : 随机获取指定集合中指定数量的元素，适合允许重复中奖的场景。</p><blockquote><p>使用 Bitmap 统计活跃用户怎么做？</p></blockquote><p>使用日期（精确到天）作为 key，然后用户 ID 为 offset，如果当日活跃过就设置为 1。</p><blockquote><p>使用 HyperLogLog 统计页面 UV 怎么做？</p></blockquote><ul><li>将访问指定页面的每个用户 ID 添加到 HyperLogLog 中。</li><li>统计指定页面的 UV。</li></ul><h2 id="_76-redis-线程模型" tabindex="-1"><a class="header-anchor" href="#_76-redis-线程模型" aria-hidden="true">#</a> 76.Redis 线程模型</h2><blockquote><p>Redis 单线程模型了解吗？</p></blockquote><p>Redis 中的文件事件处理器（file event handler）是单线程方式运行的，所以我们一般都说 Redis 是单线程模型。</p><blockquote><p>既然是单线程，那怎么监听大量的客户端连接呢？</p></blockquote><p>I/O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗（和 NIO 中的 Selector 组件很像）。</p><blockquote><p>Redis6.0 之前为什么不使用多线程</p></blockquote><ul><li>单线程编程容易并且更容易维护；</li><li>Redis 的性能瓶颈不在 CPU ，主要在内存和网络；</li><li>多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。</li></ul><blockquote><p>Redis6.0 之后为何引入了多线程？</p></blockquote><ul><li>Redis6.0 引入多线程主要是为了提高网络 IO 读写性能，因为这个算是 Redis 中的一个性能瓶颈（Redis 的瓶颈主要受限于内存和网络）。</li><li>虽然，Redis6.0 引入了多线程，但是 Redis 的多线程只是在网络数据的读写这类耗时操作上使用了，执行命令仍然是单线程顺序执行。因此，你也不需要担心线程安全问题。</li></ul><h2 id="_77-redis-内存管理" tabindex="-1"><a class="header-anchor" href="#_77-redis-内存管理" aria-hidden="true">#</a> 77.Redis 内存管理</h2><blockquote><p>Redis 给缓存数据设置过期时间有啥用？</p></blockquote><ul><li>过期时间除了有助于缓解内存的消耗。</li><li>很多时候，我们的业务场景就是需要某个数据只在某一时间段内存在，比如我们的短信验证码可能只在 1 分钟内有效，用户登录的 token 可能只在 1 天内有效。如果使用传统的数据库来处理的话，一般都是自己判断过期，这样更麻烦并且性能要差很多。</li></ul><blockquote><p>Redis 是如何判断数据是否过期的呢？</p></blockquote><ul><li>Redis 通过一个叫做过期字典（可以看作是 hash 表）来保存数据过期的时间。</li><li>过期字典的键指向 Redis 数据库中的某个 key(键)，过期字典的值是一个 long long 类型的整数，这个整数保存了 key 所指向的数据库键的过期时间（毫秒精度的 UNIX 时间戳）。</li></ul><blockquote><p>过期的数据的删除策略了解么？</p></blockquote><p>常用的过期数据的删除策略就两个（重要！自己造缓存轮子的时候需要格外考虑的东西）：</p><ul><li><p>惰性删除 ：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。</p></li><li><p>定期删除 ： 每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。</p></li><li><p>定期删除对内存更加友好，惰性删除对 CPU 更加友好。两者各有千秋，所以 Redis 采用的是 定期删除+惰性/懒汉式删除 。</p></li><li><p>但是，仅仅通过给 key 设置过期时间还是有问题的。因为还是可能存在定期删除和惰性删除漏掉了很多过期 key 的情况。这样就导致大量过期 key 堆积在内存里，然后就 Out of memory 了。</p></li></ul><blockquote><p>Redis 内存淘汰机制了解么？</p></blockquote><p>相关问题：MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据?</p><ul><li>volatile-lru（least recently used）：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰。</li><li>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰。</li><li>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰。</li><li>allkeys-lru（least recently used）：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）。</li><li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰。</li><li>no-eviction：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</li><li>volatile-lfu（least frequently used）：从已设置过期时间的数据集（server.db[i].expires）中挑选最不经常使用的数据淘汰。</li><li>allkeys-lfu（least frequently used）：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key。</li></ul><h2 id="_78-redis-持久化机制" tabindex="-1"><a class="header-anchor" href="#_78-redis-持久化机制" aria-hidden="true">#</a> 78.Redis 持久化机制</h2><blockquote><p>怎么保证 Redis 挂掉之后再重启数据可以进行恢复？</p></blockquote><ul><li>Redis 的一种持久化方式叫快照（snapshotting，RDB）。</li><li>另一种方式是只追加文件（append-only file, AOF）。</li></ul><blockquote><p>什么是 RDB 持久化？</p></blockquote><ul><li>Redis 可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。</li><li>Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。</li><li>快照持久化是 Redis 默认采用的持久化方式，在 redis.conf 配置文件中默认有此下配置。</li></ul><blockquote><p>RDB 创建快照时会阻塞主线程吗？</p></blockquote><p>Redis 提供了两个命令来生成 RDB 快照文件：</p><ul><li><code>save</code> : 主线程执行，会阻塞主线程；</li><li><code>bgsave</code> : 子线程执行，不会阻塞主线程，默认选项。</li></ul><blockquote><p>什么是 AOF 持久化？</p></blockquote><ul><li><p>与快照持久化相比，AOF 持久化的实时性更好，因此已成为主流的持久化方案。</p></li><li><p>默认情况下 Redis 没有开启 AOF（append only file）方式的持久化，可以通过 appendonly 参数开启。</p></li><li><p>开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到内存缓存 server.aof_buf 中，然后再根据 appendfsync 配置来决定何时将其同步到硬盘中的 AOF 文件。</p></li><li><p>AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 dir 参数设置的，默认的文件名是 <code>appendonly.aof</code>。</p></li><li><p>在 Redis 的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>appendfsync always    <span class="token comment">#每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度</span>
appendfsync everysec  <span class="token comment">#每秒钟同步一次，显式地将多个写命令同步到硬盘</span>
appendfsync no
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了兼顾数据和写入性能，用户可以考虑 <code>appendfsync everysec</code> 选项 ，让 Redis 每秒同步一次 AOF 文件，Redis 性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis 还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。</p></li></ul><blockquote><p>AOF 日志是如何实现的？</p></blockquote><ul><li>关系型数据库（如 MySQL）通常都是执行命令之前记录日志（方便故障恢复），而 Redis AOF 持久化机制是在执行完命令之后再记录日志。</li><li>为什么是在执行完命令之后记录日志呢？ <ul><li>避免额外的检查开销，AOF 记录日志不会对命令进行语法检查。</li><li>在命令执行完之后再记录，不会阻塞当前的命令执行。</li></ul></li><li>这样也带来了风险： <ul><li>如果刚执行完命令 Redis 就宕机会导致对应的修改丢失。</li><li>可能会阻塞后续其他命令的执行（AOF 记录日志是在 Redis 主线程中进行的）。</li></ul></li></ul><blockquote><p>AOF 重写了解吗？</p></blockquote><ul><li>当 AOF 变得太大时，Redis 能够在后台自动重写 AOF 产生一个新的 AOF 文件，这个新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。</li><li>AOF 重写是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有 AOF 文件进行任何读入、分析或者写入操作。</li></ul><blockquote><p>如何选择 RDB 和 AOF？</p></blockquote><p><strong>RDB 比 AOF 优秀的地方</strong> ：</p><ul><li>RDB 文件存储的内容是经过压缩的二进制数据， 保存着某个时间点的数据集，文件很小，适合做数据的备份，灾难恢复。AOF 文件存储的是每一次写命令，类似于 MySQL 的 binlog 日志，通常会比 RDB 文件大很多。当 AOF 变得太大时，Redis 能够在后台自动重写 AOF。新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。不过， Redis 7.0 版本之前，如果在重写期间有写入命令，AOF 可能会使用大量内存，重写期间到达的所有写入命令都会写入磁盘两次。</li><li>使用 RDB 文件恢复数据，直接解析还原数据即可，不需要一条一条地执行命令，速度非常快。而 AOF 则需要依次执行每个写命令，速度非常慢。也就是说，与 AOF 相比，恢复大数据集的时候，RDB 速度更快。</li></ul><p><strong>AOF 比 RDB 优秀的地方</strong> ：</p><ul><li>RDB 的数据安全性不如 AOF，没有办法实时或者秒级持久化数据。生成 RDB 文件的过程是比繁重的， 虽然 BGSAVE 子进程写入 RDB 文件的工作不会阻塞主线程，但会对机器的 CPU 资源和内存资源产生影响，严重的情况下甚至会直接把 Redis 服务干宕机。AOF 支持秒级数据丢失（取决 fsync 策略，如果是 everysec，最多丢失 1 秒的数据），仅仅是追加命令到 AOF 文件，操作轻量。</li><li>RDB 文件是以特定的二进制格式保存的，并且在 Redis 版本演进中有多个版本的 RDB，所以存在老版本的 Redis 服务不兼容新版本的 RDB 格式的问题。</li><li>AOF 以一种易于理解和解析的格式包含所有操作的日志。你可以轻松地导出 AOF 文件进行分析，你也可以直接操作 AOF 文件来解决一些问题。比如，如果执行<code>FLUSHALL</code>命令意外地刷新了所有内容后，只要 AOF 文件没有被重写，删除最新命令并重启即可恢复之前的状态。</li></ul><h2 id="_79-缓存问题" tabindex="-1"><a class="header-anchor" href="#_79-缓存问题" aria-hidden="true">#</a> 79.缓存问题</h2><h3 id="缓存穿透" tabindex="-1"><a class="header-anchor" href="#缓存穿透" aria-hidden="true">#</a> 缓存穿透</h3><ul><li>缓存穿透说简单点就是大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。举个例子：某个黑客故意制造我们缓存中不存在的 key 发起大量请求，导致大量请求落到数据库。</li><li>最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。</li><li>缓存无效 key：这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。</li><li>布隆过滤器：布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地判断一个给定数据是否存在于海量数据中。我们需要的就是判断 key 是否合法，有没有感觉布隆过滤器就是我们想要找的那个“人”。布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。</li></ul><h3 id="缓存雪崩" tabindex="-1"><a class="header-anchor" href="#缓存雪崩" aria-hidden="true">#</a> 缓存雪崩</h3><ul><li>缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。</li><li>有一些被大量访问数据（热点缓存）在某一时刻大面积失效，导致对应的请求直接落到了数据库上。</li><li>针对 Redis 服务不可用的情况： <ul><li>采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。</li><li>限流，避免同时处理大量的请求。</li></ul></li><li>针对热点缓存失效的情况： <ul><li>设置不同的失效时间比如随机设置缓存的失效时间。</li><li>缓存永不失效。</li></ul></li></ul><h2 id="_80-3种常用的缓存读写策略" tabindex="-1"><a class="header-anchor" href="#_80-3种常用的缓存读写策略" aria-hidden="true">#</a> 80.3种常用的缓存读写策略</h2><h3 id="cache-aside-pattern-旁路缓存模式" tabindex="-1"><a class="header-anchor" href="#cache-aside-pattern-旁路缓存模式" aria-hidden="true">#</a> Cache Aside Pattern（旁路缓存模式）</h3><ul><li>Cache Aside Pattern 是我们平时使用比较多的一个缓存读写模式，比较适合读请求比较多的场景。</li><li>Cache Aside Pattern 中服务端需要同时维系 DB 和 cache，并且是以 DB 的结果为准。</li><li>缓存读写步骤： <ul><li>写：（1）先更新 DB。（2）然后直接删除 cache 。</li><li>读：（1）从 cache 中读取数据，读取到就直接返回。（2）cache中读取不到的话，就从 DB 中读取数据返回。（3）再把数据放到 cache 中。</li></ul></li></ul><blockquote><p>在写数据的过程中，可以先删除 cache ，后更新 DB 么？</p></blockquote><ul><li>那肯定是不行的！因为这样可能会造成数据库（DB）和缓存（Cache）数据不一致的问题。为什么呢？比如说请求1 先写数据A，请求2随后读数据A的话就很有可能产生数据不一致性的问题。</li></ul><blockquote><p>在写数据的过程中，先更新DB，后删除cache就没有问题了么？</p></blockquote><ul><li>理论上来说还是可能会出现数据不一致性的问题，不过概率非常小，因为缓存的写入速度是比数据库的写入速度快很多！</li><li>比如请求1先读数据 A，请求2随后写数据A，并且数据A不在缓存中的话也有可能产生数据不一致性的问题。</li></ul><blockquote><p>缺陷1：首次请求数据一定不在 cache 的问题</p></blockquote><p>可以将热点数据可以提前放入cache 中。</p><blockquote><p>写操作比较频繁的话导致cache中的数据会被频繁被删除，这样会影响缓存命中率 。</p></blockquote><ul><li>数据库和缓存数据强一致场景 ：更新DB的时候同样更新cache，不过我们需要加一个锁/分布式锁来保证更新cache的时候不存在线程安全问题。</li><li>可以短暂地允许数据库和缓存数据不一致的场景 ：更新DB的时候同样更新cache，但是给缓存加一个比较短的过期时间，这样的话就可以保证即使数据不一致的话影响也比较小。</li></ul><h3 id="read-write-through-pattern-读写穿透" tabindex="-1"><a class="header-anchor" href="#read-write-through-pattern-读写穿透" aria-hidden="true">#</a> Read/Write Through Pattern（读写穿透）</h3><ul><li>Read/Write Through Pattern 中服务端把 cache 视为主要数据存储，从中读取数据并将数据写入其中。cache 服务负责将此数据读取和写入 DB，从而减轻了应用程序的职责。</li><li>Read/Write Through Pattern 中服务端把 cache 视为主要数据存储，从中读取数据并将数据写入其中。cache 服务负责将此数据读取和写入 DB，从而减轻了应用程序的职责。</li><li>写（Write Through）： <ul><li>先查 cache，cache 中不存在，直接更新 DB。</li><li>cache 中存在，则先更新 cache，然后 cache 服务自己更新 DB（同步更新 cache 和 DB）。</li></ul></li><li>读(Read Through)： <ul><li>从 cache 中读取数据，读取到就直接返回 。</li><li>读取不到的话，先从 DB 加载，写入到 cache 后返回响应。</li></ul></li></ul><h3 id="write-behind-pattern-异步缓存写入" tabindex="-1"><a class="header-anchor" href="#write-behind-pattern-异步缓存写入" aria-hidden="true">#</a> Write Behind Pattern（异步缓存写入）</h3><ul><li>Read/Write Through 是同步更新 cache 和 DB，而 Write Behind Caching 则是只更新缓存，不直接更新 DB，而是改为异步批量的方式来更新 DB。</li><li>这种策略在我们平时开发过程中也非常非常少见，但是不代表它的应用场景少，比如消息队列中消息的异步写入磁盘、MySQL 的 InnoDB Buffer Pool 机制都用到了这种策略。</li></ul><h2 id="_81-redis-内存碎片" tabindex="-1"><a class="header-anchor" href="#_81-redis-内存碎片" aria-hidden="true">#</a> 81.Redis 内存碎片</h2><blockquote><p>什么是内存碎片?</p></blockquote><ul><li>你可以将内存碎片简单地理解为那些不可用的空闲内存。</li><li>举个例子：操作系统为你分配了 32 字节的连续内存空间，而你存储数据实际只需要使用 24 字节内存空间，那这多余出来的 8 字节内存空间如果后续没办法再被分配存储其他数据的话，就可以被称为内存碎片。</li><li>Redis 内存碎片虽然不会影响 Redis 性能，但是会增加内存消耗。</li></ul><blockquote><p>为什么会有 Redis 内存碎片?</p></blockquote><ul><li>Redis 存储数据的时候向操作系统申请的内存空间可能会大于数据实际需要的存储空间。</li><li>频繁修改 Redis 中的数据也会产生内存碎片。当 Redis 中的某个数据删除时，Redis 通常不会轻易释放内存给操作系统。</li></ul><blockquote><p>如何查看 Redis 内存碎片的信息？</p></blockquote><ul><li><p>使用 info memory 命令即可查看 Redis 内存相关的信息。</p></li><li><p>Redis 内存碎片率的计算公式：mem_fragmentation_ratio （内存碎片率）= used_memory_rss (操作系统实际分配给 Redis 的物理内存空间大小)/ used_memory(Redis 内存分配器为了存储数据实际申请使用的内存空间大小)</p><p>也就是说，mem_fragmentation_ratio （内存碎片率）的值越大代表内存碎片率越严重。</p></li><li><p>通常情况下，我们认为 mem_fragmentation_ratio &gt; 1.5 的话才需要清理内存碎片。 mem_fragmentation_ratio &gt; 1.5 意味着你使用 Redis 存储实际大小 2G 的数据需要使用大于 3G 的内存。</p></li></ul><blockquote><p>如何清理 Redis 内存碎片？</p></blockquote><p>Redis4.0-RC3 版本以后自带了内存整理，可以避免内存碎片率过大的问题。</p><p>直接通过 <code>config set</code> 命令将 <code>activedefrag</code> 配置项设置为 <code>yes</code> 即可。</p></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/overau/my-notes/blob/master/src/interview/01.Java基础和数据库.md" rel="noopener noreferrer" target="_blank" aria-label="在 GitHub 上编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->在 GitHub 上编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item update-time"><span class="label">上次编辑于: </span><!----></div><div class="meta-item contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: deciphers@163.com">HeJin</span><!--]--><!--]--></div></footer><nav class="page-nav"><!----><a href="/interview/02.%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6.html" class="nav-link next" aria-label="常用框架"><div class="hint">下一页<span class="arrow right"></span></div><div class="link">常用框架<!----></div></a></nav><!----><!----><!--]--></main><!--]--><footer class="footer-wrapper"><div class="footer"></div><div class="copyright">Copyright © 2023 HeJin</div></footer><!--]--></div><!--]--><!----><!----><!--]--></div>
    <script type="module" src="/assets/app-00bd0cef.js" defer></script>
  </body>
</html>
